<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Earth Defender</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Grotesk:wght@600;700&family=JetBrains+Mono:wght@500;600&display=swap');
        
        :root {
            --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-display: 'Space Grotesk', 'Inter', sans-serif;
            --font-mono: 'JetBrains Mono', 'Courier New', monospace;
            
            --text-xs: 0.688rem;
            --text-sm: 0.813rem;
            --text-base: 1rem;
            --text-lg: 1.25rem;
            --text-xl: 1.563rem;
            --text-2xl: 1.953rem;
            --text-3xl: 2.441rem;
            
            --leading-tight: 1.2;
            --leading-normal: 1.5;
            --leading-relaxed: 1.7;
            
            --tracking-tight: -0.02em;
            --tracking-normal: 0;
            --tracking-wide: 0.025em;
            
            --color-bg-base: #0a0e1a;
            --color-bg-elevated: #121825;
            --color-bg-overlay: #1a2332;
            --color-accent: #22d3ee;
            --color-accent-hover: #06b6d4;
            --color-success: #10b981;
            --color-warning: #f59e0b;
            --color-danger: #ef4444;
            --color-text-primary: #f8fafc;
            --color-text-secondary: #cbd5e1;
            --color-text-tertiary: #64748b;
            --color-border: rgba(255, 255, 255, 0.1);
            
            --space-1: 0.25rem;
            --space-2: 0.5rem;
            --space-3: 0.75rem;
            --space-4: 1rem;
            --space-5: 1.5rem;
            --space-6: 2rem;
            --space-8: 3rem;
            
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.5);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.4);
            --shadow-lg: 0 10px 15px rgba(0,0,0,0.3);
            --shadow-xl: 0 20px 25px rgba(0,0,0,0.25);
            
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --radius-full: 9999px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: var(--color-bg-base);
            overflow: hidden;
            font-family: var(--font-primary);
            color: var(--color-text-primary);
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            background: var(--color-bg-base);
            touch-action: none;
            image-rendering: pixelated;
        }

        #titleImage {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 300px;
            z-index: 201;
            image-rendering: auto;
            mix-blend-mode: lighten;
            opacity: 0.95;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: var(--space-4);
            display: flex;
            justify-content: space-between;
            z-index: 100;
            pointer-events: none;
            clip-path: inset(0);
        }

        .hud-group {
            background: rgba(18, 24, 37, 0.85);
            backdrop-filter: blur(8px);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            padding: var(--space-3) var(--space-4);
            display: flex;
            gap: var(--space-5);
            box-shadow: var(--shadow-md);
        }

        .hud-stat {
            display: flex;
            flex-direction: column;
            gap: var(--space-1);
        }

        .hud-label {
            font-size: var(--text-xs);
            font-weight: 500;
            color: var(--color-text-tertiary);
        }

        .hud-value {
            font-family: var(--font-mono);
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--color-text-primary);
            font-variant-numeric: tabular-nums;
        }

        #comboCounter {
            position: absolute;
            top: 75%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: var(--font-display);
            font-weight: 700;
            color: var(--color-warning);
            text-shadow: 0 0 20px rgba(245, 158, 11, 0.8);
            pointer-events: none;
            z-index: 150;
            opacity: 0;
            transition: opacity 0.2s, font-size 0.2s;
        }

        #missileButton {
            width: 80px;
            height: 80px;
            bottom: var(--space-4);
            right: var(--space-4);
            left: auto;
            transform: none;
            background: var(--color-danger);
            color: var(--color-text-primary);
            border: 2px solid rgba(239, 68, 68, 0.5);
            border-radius: var(--radius-full);
            font-size: var(--text-sm);
            font-weight: 600;
            cursor: pointer;
            z-index: 100;
            transition: all 0.2s;
            box-shadow: var(--shadow-lg);
            position: absolute;
        }

        #missileButton:hover {
            background: #dc2626;
            transform: scale(1.05);
        }

        #missileButton:active {
            transform: scale(0.95);
        }

        #menu {
            position: absolute;
            top: 80%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
        }
        
        #menu .button {
            width: 120px;
            padding: 8px 12px;
            font-size: 14px;
            margin: 4px;
        }
        
        #menu .difficulty-buttons {
            margin-top: 12px;
        }
        
        #menu .difficulty-buttons .button {
            width: 80px;
            padding: 6px 10px;
            font-size: 12px;
        }

        .button {
            font-family: var(--font-primary);
            font-size: var(--text-base);
            font-weight: 600;
            letter-spacing: var(--tracking-wide);
            background: var(--color-accent);
            color: var(--color-bg-base);
            border: none;
            border-radius: var(--radius-md);
            padding: var(--space-4) var(--space-6);
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: var(--shadow-md);
            margin: var(--space-2);
        }

        .button:hover {
            background: var(--color-accent-hover);
            box-shadow: var(--shadow-lg);
        }

        .button-secondary {
            background: var(--color-bg-elevated);
            color: var(--color-text-primary);
            border: 1px solid var(--color-border);
        }

        .button-secondary:hover {
            background: var(--color-bg-overlay);
            border-color: var(--color-accent);
        }

        #shop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 900px;
            max-height: 85vh;
            background: var(--color-bg-elevated);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-6);
            display: none;
            flex-direction: column;
            z-index: 300;
            box-shadow: var(--shadow-xl);
        }

        .shop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-5);
            padding-bottom: var(--space-4);
            border-bottom: 1px solid var(--color-border);
        }

        .shop-header h2 {
            font-family: var(--font-display);
            font-size: var(--text-2xl);
            font-weight: 600;
            letter-spacing: var(--tracking-tight);
        }

        .shop-balance {
            font-family: var(--font-mono);
            font-size: var(--text-xl);
            font-weight: 600;
            color: var(--color-warning);
            font-variant-numeric: tabular-nums;
        }

        .shop-tabs {
            display: flex;
            gap: var(--space-2);
            margin-bottom: var(--space-5);
        }

        .tab {
            font-size: var(--text-sm);
            font-weight: 500;
            padding: var(--space-2) var(--space-4);
            background: transparent;
            color: var(--color-text-secondary);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab.active {
            background: rgba(34, 211, 238, 0.1);
            color: var(--color-accent);
            border-color: var(--color-accent);
        }

        .shop-items {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: var(--space-4);
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        
        .shop-items::-webkit-scrollbar {
            display: none;
        }

        .item-card {
            background: #000;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            padding: var(--space-4);
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
            transition: all 0.2s;
            text-align: center;
        }

        .item-card:hover {
            border-color: var(--color-accent);
            box-shadow: var(--shadow-md);
        }

        .item-card.equipped {
            border-color: var(--color-success);
            background: #000;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.3);
        }

        .item-sprite {
            width: 120px;
            height: 120px;
            margin: 0 auto;
            object-fit: contain;
            image-rendering: pixelated;
            background: #000;
            padding: 8px;
            border-radius: 4px;
        }

        .item-name {
            font-size: var(--text-base);
            font-weight: 600;
            color: var(--color-accent);
            text-align: center;
        }

        .item-desc {
            font-size: 0.7rem;
            line-height: var(--leading-normal);
            color: var(--color-text-secondary);
            text-align: center;
        }

        .item-price {
            font-family: var(--font-mono);
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--color-warning);
            text-align: center;
            font-variant-numeric: tabular-nums;
        }

        .item-equipped-badge {
            font-size: var(--text-xs);
            font-weight: 600;
            color: var(--color-success);
            text-align: center;
        }

        .interstitial-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            background: var(--color-bg-elevated);
            border-radius: var(--radius-lg);
            padding: var(--space-6);
            display: none;
            flex-direction: column;
            gap: var(--space-5);
            z-index: 400;
            box-shadow: var(--shadow-xl);
            text-align: center;
            max-height: 85vh;
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        
        .interstitial-screen::-webkit-scrollbar {
            display: none;
        }
        .interstitial-screen h2 {
            font-family: var(--font-display);
            font-size: var(--text-2xl);
            font-weight: 600;
            color: var(--color-accent);
        }
        .interstitial-screen p {
            font-size: var(--text-base);
            color: var(--color-text-secondary);
            margin-top: calc(var(--space-2) * -1);
            margin-bottom: var(--space-2);
            text-align: left;
            line-height: var(--leading-relaxed);
        }
         #waveChoice {
             border: 2px solid var(--color-accent);
        }
        #waveTransition {
            max-width: 400px;
        }
        #tutorial {
            text-align: left;
        }
        #tutorial p {
             text-align: left;
        }
        #tutorial h2 {
             text-align: center;
        }
        #tutorial .button-container {
            text-align: center;
        }

        .choice-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: var(--space-4);
        }

        .choice-card {
            background: var(--color-bg-overlay);
            border: 2px solid var(--color-border);
            border-radius: var(--radius-md);
            padding: var(--space-5);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
        }

        .choice-card:hover {
            border-color: var(--color-accent);
            box-shadow: var(--shadow-lg);
            background: rgba(34, 211, 238, 0.05);
        }

        .choice-card-name {
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--color-accent);
            text-align: center;
        }

        .choice-card-desc {
            font-size: var(--text-sm);
            line-height: var(--leading-relaxed);
            color: var(--color-text-secondary);
            text-align: left;
        }

        .choice-card-effect {
            font-size: var(--text-base);
            font-weight: 600;
            color: var(--color-success);
            text-align: center;
            padding: var(--space-2);
            background: rgba(16, 185, 129, 0.1);
            border-radius: var(--radius-sm);
        }

        #deathScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 500px;
            background: var(--color-bg-elevated);
            border: 2px solid var(--color-danger);
            border-radius: var(--radius-lg);
            padding: var(--space-6);
            display: none;
            flex-direction: column;
            gap: var(--space-5);
            z-index: 400;
            box-shadow: var(--shadow-xl);
        }

        #deathScreen h2 {
            font-family: var(--font-display);
            font-size: var(--text-2xl);
            font-weight: 600;
            color: var(--color-danger);
            text-align: center;
        }

        .death-stats {
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
        }

        .death-stat-row {
            display: flex;
            justify-content: space-between;
            font-size: var(--text-base);
            padding: var(--space-2) 0;
            border-bottom: 1px solid var(--color-border);
        }

        .death-stat-label {
            color: var(--color-text-secondary);
        }

        .death-stat-value {
            font-family: var(--font-mono);
            font-weight: 600;
            color: var(--color-text-primary);
            font-variant-numeric: tabular-nums;
        }

        .death-recommendation {
            background: rgba(34, 211, 238, 0.1);
            border: 1px solid var(--color-accent);
            border-radius: var(--radius-md);
            padding: var(--space-4);
            font-size: var(--text-sm);
            line-height: var(--leading-relaxed);
            color: var(--color-text-secondary);
        }

        #victoryScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 600px;
            background: var(--color-bg-elevated);
            border: 2px solid var(--color-success);
            border-radius: var(--radius-lg);
            padding: var(--space-6);
            display: none;
            flex-direction: column;
            align-items: center;
            gap: var(--space-5);
            z-index: 500;
            box-shadow: var(--shadow-xl);
        }

        #victoryScreen h2 {
            font-family: var(--font-display);
            font-size: var(--text-3xl);
            font-weight: 700;
            color: var(--color-success);
            text-align: center;
        }

        .album-art {
            width: 250px;
            height: 250px;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            margin: var(--space-4) 0;
        }

        .credits-text {
            text-align: center;
            font-size: var(--text-lg);
            line-height: var(--leading-relaxed);
            color: var(--color-text-primary);
        }

        .credits-text a {
            color: var(--color-accent);
            text-decoration: none;
            transition: color 0.2s;
        }

        .credits-text a:hover {
            color: var(--color-accent-hover);
            text-decoration: underline;
        }

        .wave-modifier-banner {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(18, 24, 37, 0.95);
            border: 2px solid var(--color-warning);
            border-radius: var(--radius-lg);
            padding: var(--space-5) var(--space-6);
            z-index: 250;
            box-shadow: var(--shadow-xl);
            animation: slideDown 0.5s ease-out;
        }

        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        .wave-modifier-title {
            font-family: var(--font-display);
            font-size: var(--text-xl);
            font-weight: 700;
            color: var(--color-warning);
            text-align: center;
            margin-bottom: var(--space-2);
        }

        .wave-modifier-desc {
            font-size: var(--text-sm);
            color: var(--color-text-secondary);
            text-align: center;
        }

        .damage-number {
            position: absolute;
            font-family: var(--font-display);
            font-weight: 700;
            font-size: var(--text-lg);
            color: var(--color-danger);
            text-shadow: 0 0 10px rgba(239, 68, 68, 0.8);
            pointer-events: none;
            z-index: 200;
            animation: floatUp 1s ease-out forwards;
        }

        @keyframes floatUp {
            to {
                transform: translateY(-50px);
                opacity: 0;
            }
        }

        @media (max-width: 768px) {
            .hud-group {
                padding: var(--space-2) var(--space-3);
                gap: var(--space-3);
            }
            .hud-label {
                font-size: 0.625rem;
            }
            .hud-value {
                font-size: var(--text-base);
            }
            .choice-cards {
                grid-template-columns: 1fr;
            }
        }
    
        #audioControls {
            position: absolute;
            top: var(--space-4);
            right: var(--space-4);
            display: flex;
            gap: var(--space-2);
            z-index: 1000;
        }
        
        .audio-btn {
            width: 40px;
            height: 40px;
            border-radius: var(--radius-full);
            background: var(--color-bg-elevated);
            border: 1px solid var(--color-border);
            color: var(--color-text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--text-lg);
            transition: all 0.2s ease;
        }
        
        .audio-btn:hover {
            background: var(--color-bg-overlay);
            border-color: var(--color-accent);
        }
        
        .audio-btn.muted {
            color: var(--color-danger);
            background: rgba(239, 68, 68, 0.1);
        }
    </style>
</head>
<body>
    <div id="audioControls" style="display: flex;">
        <button class="audio-btn" id="muteBtn" onclick="toggleAudio()" title="Toggle Sound">
            🔊
        </button>
    </div>

    <canvas id="gameCanvas"></canvas>
    
    <div id="fpsCounter" style="position: absolute; top: 10px; right: 10px; font-family: 'JetBrains Mono', monospace; font-size: 12px; color: #0f0; background: rgba(0,0,0,0.7); padding: 4px 8px; border-radius: 4px; z-index: 1000; display: none;">FPS: 60</div>
    
    <img id="titleImage" src="assets/gametitle.jpg" alt="Earth Defender" style="display: block;">
    
    <div id="hud">
        <div class="hud-group">
            <div class="hud-stat">
                <span class="hud-label">Wave</span>
                <span class="hud-value" id="waveDisplay">1</span>
            </div>
            <div class="hud-stat">
                <span class="hud-label">Score</span>
                <span class="hud-value" id="scoreDisplay">0</span>
            </div>
        </div>
        <div class="hud-group">
            <div class="hud-stat">
                <span class="hud-label">Lives</span>
                <span class="hud-value" id="livesDisplay">3</span>
            </div>
            <div class="hud-stat">
                <span class="hud-label">Coins</span>
                <span class="hud-value" id="coinsDisplay">100</span>
            </div>
            <div class="hud-stat">
                <span class="hud-label">Missiles</span>
                <span class="hud-value" id="missilesDisplay">3</span>
            </div>
        </div>
    </div>

    <div id="comboCounter"></div>

    <button id="missileButton" onclick="if(Game) Game.launchMissile()">
        🚀<br>Fire
    </button>
    
    <div id="menu">
        <button class="button" onclick="if(Game) Game.startGame('normal')">Start</button>
        <button class="button button-secondary" onclick="if(Game) Game.showShop()">Shop</button>
        <button class="button button-secondary" onclick="if(Game) Game.showTutorial()">Help</button>
        <div class="difficulty-buttons">
             <button class="button" onclick="if(Game) Game.startGame('easy')">Easy</button>
             <button class="button" onclick="if(Game) Game.startGame('normal')">Normal</button>
             <button class="button" onclick="if(Game) Game.startGame('hard')">Hard</button>
        </div>
    </div>

    <div id="shop">
        <div class="shop-header">
            <h2>Upgrades</h2>
            <div>
                <span class="shop-balance" id="shopBalance">💰 100</span>
                <button class="button button-secondary" style="margin-left: 16px;" onclick="if(Game) Game.closeShop()">Close</button>
            </div>
        </div>
        <div class="shop-tabs">
            <button class="tab active" onclick="if(Game) Game.switchTab('weapons')">Weapons</button>
            <button class="tab" onclick="if(Game) Game.switchTab('shields')">Shields</button>
            <button class="tab" onclick="if(Game) Game.switchTab('systems')">Systems</button>
        </div>
        <div id="shopItems" class="shop-items"></div>
    </div>

    <div id="waveChoice" class="interstitial-screen">
        <h2>Choose Your Upgrade</h2>
        <p>Pick one to power up for the next wave.</p>
        <div id="choiceCards" class="choice-cards"></div>
    </div>

    <div id="waveTransition" class="interstitial-screen">
        <h2>Wave Complete!</h2>
        <p>Prepare for the next assault.</p>
        <div>
            <button class="button" onclick="if(Game) Game.resumeGame()">Next Wave</button>
            <button class="button button-secondary" onclick="if(Game) Game.showInGameShop()">Visit Shop</button>
        </div>
    </div>

    <div id="tutorial" class="interstitial-screen">
        <h2>How to Play</h2>
        <p>
            <strong>Objective:</strong> Defend Earth by destroying all incoming enemy ships before they reach the planet.<br><br>
            <strong>Controls:</strong> Your ship automatically orbits Earth. Use your mouse on desktop or swipe on mobile to aim your ship's cannon. Firing is automatic.<br><br>
            <strong>Missiles:</strong> Tap the missile button in the corner to launch a powerful, homing missile. You get more between waves.<br><br>
            <strong>Upgrades:</strong> After each wave, you get to choose one of three temporary upgrades. Use coins earned to buy permanent upgrades in the shop.
        </p>
        <div class="button-container">
            <button class="button" onclick="if(Game) Game.closeTutorial()">Back to Menu</button>
        </div>
    </div>

    <div id="pauseScreen" class="interstitial-screen" style="display: none; max-width: 400px;">
        <h2>Paused</h2>
        <p style="text-align: center;">Press ESC to resume</p>
    </div>

    <div id="deathScreen">
        <h2>Mission Failed</h2>
        <div id="deathStats" class="death-stats"></div>
        <div class="death-recommendation" id="deathRecommendation"></div>
        <button class="button" onclick="if(Game) Game.closeDeathScreen()">Continue</button>
    </div>

    <div id="victoryScreen">
        <h2>Victory!</h2>
        <img src="assets/IMG_1538.PNG" class="album-art" alt="Oh Death Album Art">
        <div class="credits-text">
            <p><strong>Game Design</strong><br>D_York</p>
            <p><strong>Original Music by D_York</strong><br>
            Represented by United Masters</p>
            <p>Available on <a href="https://unitedmasters.com/m/oh-death-1" target="_blank">Spotify &amp; Apple Music</a></p>
        </div>
        <button class="button" onclick="if(Game) Game.closeVictoryScreen()">Main Menu</button>
    </div>

    
    <script>
        'use strict';
        
        const GAME_VERSION = '1.0.1';
        const EARTH_COLLISION_RADIUS = 45;
        const EARTH_IMPACT_RADIUS = 35;
        const SHIELD_VISUAL_RADIUS = 50;
        const ENEMY_HIT_RADIUS = 25;
        const BOSS_HIT_RADIUS = 80;
        const MISSILE_SEARCH_RADIUS = 100;
        const STUCK_TIMER_THRESHOLD = 3;
        
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.musicTracks = {};
                this.currentMusic = null;
                this.currentPlaylist = [];
                this.currentTrackIndex = 0;
                this.musicVolume = 0.4;
                this.sfxVolume = 0.6;
                this.muted = false;
                this.baseMusicVolume = 0.4;
                this.duckingActive = false;
                this.targetVolume = 0.4;
                
                this.tracks = {
                    menu: ['assets/audio/hippiedancers_-_6_9_24__2_26_PM.m4a'],
                    gameplay: [
                        'assets/audio/m33_-_4_26_25__11_13_AM.m4a',
                        'assets/audio/MIAMI__mret_-_5_27_24__5_09_PM_.m4a',
                        'assets/audio/goodroots - 1_17_25, 9.41 PM.m4a',
                        'assets/audio/newleed - 9_28_24, 6.48 PM.m4a',
                        'assets/audio/hippiedancers_-_6_9_24__2_26_PM.m4a'
                    ],
                    boss: [
                        'assets/audio/monster.mp3',
                        'assets/audio/dumplin_-_7_6_24__8_51_PM.m4a'
                    ],
                    victory: ['assets/audio/propane2 - 12_21_24, 10.27 AM.m4a'],
                    gameover: ['assets/audio/gameover.mp3']
                };
                
                this.init();
            }
            
            duckMusic(duration = 0.3, amount = 0.5) {
                if (!this.currentMusic || this.muted) return;
                this.duckingActive = true;
                const duckedVolume = this.baseMusicVolume * amount;
                this.targetVolume = duckedVolume;
                this.smoothTransition(this.currentMusic.volume, duckedVolume, 100);
                setTimeout(() => {
                    this.duckingActive = false;
                    this.targetVolume = this.baseMusicVolume;
                    this.smoothTransition(this.currentMusic.volume, this.baseMusicVolume, 200);
                }, duration * 1000);
            }
            
            smoothTransition(from, to, duration) {
                if (!this.currentMusic) return;
                const steps = 10;
                const stepTime = duration / steps;
                const volumeStep = (to - from) / steps;
                let currentStep = 0;
                const interval = setInterval(() => {
                    if (!this.currentMusic || this.muted) {
                        clearInterval(interval);
                        return;
                    }
                    currentStep++;
                    this.currentMusic.volume = from + (volumeStep * currentStep);
                    if (currentStep >= steps) clearInterval(interval);
                }, stepTime);
            }
            
            async init() {
                try {
                    if (!window.AudioContext && !window.webkitAudioContext) {
                        console.warn('Web Audio API not supported. Audio will be disabled.');
                        return;
                    }
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    for (const playlist of Object.values(this.tracks)) {
                        for (const path of playlist) {
                            if (!this.musicTracks[path]) {
                                try {
                                    const audio = new Audio(path);
                                    audio.loop = false;
                                    audio.volume = 0;
                                    audio.preload = 'auto';
                                    await new Promise((resolve, reject) => {
                                        audio.oncanplaythrough = resolve;
                                        audio.onerror = () => {
                                            console.warn(`Failed to load audio: ${path}`);
                                            resolve();
                                        };
                                        audio.load();
                                        setTimeout(resolve, 5000);
                                    });
                                    this.musicTracks[path] = audio;
                                } catch (err) {
                                    console.warn(`Audio load error: ${err.message}`);
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Audio initialization failed:', error);
                    this.audioContext = null;
                }
            }

            shufflePlaylist(playlist) {
                for (let i = playlist.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [playlist[i], playlist[j]] = [playlist[j], playlist[i]];
                }
            }

            playNextTrackInPlaylist() {
                if (this.currentPlaylist.length <= 1 || this.muted) return;
                this.currentTrackIndex = (this.currentTrackIndex + 1) % this.currentPlaylist.length;
                if (this.currentTrackIndex === 0) this.shufflePlaylist(this.currentPlaylist);
                const nextTrackPath = this.currentPlaylist[this.currentTrackIndex];
                this.playTrack(nextTrackPath, 4000, true);
            }
            
            playMusic(playlistName, fadeTime = 2000) {
                if (this.muted || !this.tracks[playlistName] || this.tracks[playlistName].length === 0) return;
                const newPlaylist = this.tracks[playlistName];
                this.currentPlaylist = [...newPlaylist];
                if(this.currentPlaylist.length > 1) this.shufflePlaylist(this.currentPlaylist);
                this.currentTrackIndex = 0;
                const trackPath = this.currentPlaylist[this.currentTrackIndex];
                const isPlaylist = (playlistName === 'gameplay' || playlistName === 'menu') && this.currentPlaylist.length > 1;
                this.playTrack(trackPath, fadeTime, isPlaylist);
            }

            playTrack(trackPath, fadeTime, isPlaylist = false) {
                if (this.muted || !this.musicTracks[trackPath]) return;
                const newTrack = this.musicTracks[trackPath];
                if (this.currentMusic === newTrack && !newTrack.paused) return;
                if (this.currentMusic) {
                    this.currentMusic.onended = null;
                    this.fadeOut(this.currentMusic, fadeTime);
                }
                this.currentMusic = newTrack;
                newTrack.currentTime = 0;
                newTrack.play().then(() => {
                    this.fadeIn(newTrack, fadeTime, this.musicVolume);
                }).catch(err => console.warn('Audio play failed:', err));

                if (isPlaylist) {
                    newTrack.loop = false;
                    newTrack.onended = () => this.playNextTrackInPlaylist();
                } else {
                    newTrack.onended = null;
                    newTrack.loop = true;
                }
            }
            
            fadeIn(audio, duration, targetVolume) {
                if (!audio) return;
                const steps = 50;
                const stepTime = duration / steps;
                audio.volume = 0;
                const volumeIncrement = targetVolume / steps;
                const interval = setInterval(() => {
                    if (!audio || audio.volume >= targetVolume - volumeIncrement || this.muted) {
                        if (audio) audio.volume = this.muted ? 0 : targetVolume;
                        clearInterval(interval);
                        return;
                    }
                    audio.volume += volumeIncrement;
                }, stepTime);
            }
            
            fadeOut(audio, duration) {
                if (!audio) return;
                const steps = 50;
                const stepTime = duration / steps;
                const startVolume = audio.volume;
                if (startVolume === 0) {
                    audio.pause();
                    return;
                }
                const volumeDecrement = startVolume / steps;
                const interval = setInterval(() => {
                    if (!audio || audio.volume <= volumeDecrement) {
                        if (audio) {
                            audio.pause();
                            audio.volume = 0;
                        }
                        clearInterval(interval);
                        return;
                    }
                    audio.volume -= volumeDecrement;
                }, stepTime);
            }
            
            stopMusic(fadeTime = 1000) {
                if (this.currentMusic) {
                    this.currentMusic.onended = null;
                    this.fadeOut(this.currentMusic, fadeTime);
                }
            }
            
            playSFX(type) {
                if (this.muted || !this.audioContext) return;
                if (['explosion', 'bossExplode', 'missile', 'bossHit'].includes(type)) {
                    this.duckMusic(0.3, 0.5);
                }
                const ctx = this.audioContext;
                const now = ctx.currentTime;
                switch(type) {
                    case 'shoot': this.playShootSound(ctx, now); break;
                    case 'hit': this.playHitSound(ctx, now); break;
                    case 'explosion': this.playExplosionSound(ctx, now); break;
                    case 'missile': this.playMissileSound(ctx, now); break;
                    case 'powerup': this.playPowerupSound(ctx, now); break;
                    case 'upgrade': this.playUpgradeSound(ctx, now); break;
                    case 'warning': this.playWarningSound(ctx, now); break;
                    case 'waveComplete': this.playWaveCompleteSound(ctx, now); break;
                    case 'bossHit': this.playBossHitSound(ctx, now); break;
                    case 'bossExplode': this.playBossExplodeSound(ctx, now); break;
                }
            }
            
            playShootSound(ctx, now) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                gain.gain.setValueAtTime(0.3 * this.sfxVolume, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
            
            playHitSound(ctx, now) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.05);
                gain.gain.setValueAtTime(0.4 * this.sfxVolume, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            }
            
            playExplosionSound(ctx, now) {
                const bufferSize = ctx.sampleRate * 0.5;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                let last = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    data[i] = (last + 0.02 * white) / 1.02;
                    last = data[i];
                    data[i] *= 3.5;
                }
                const source = ctx.createBufferSource();
                const filter = ctx.createBiquadFilter();
                const gain = ctx.createGain();
                source.buffer = buffer;
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(800, now);
                filter.frequency.exponentialRampToValueAtTime(50, now + 0.5);
                source.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                gain.gain.setValueAtTime(0.5 * this.sfxVolume, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                source.start(now);
                source.stop(now + 0.5);
            }
            
            playBossHitSound(ctx, now) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'square';
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(30, now + 0.2);
                gain.gain.setValueAtTime(0.5 * this.sfxVolume, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            }
            
            playBossExplodeSound(ctx, now) {
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => this.playExplosionSound(ctx, ctx.currentTime), i * 100);
                }
            }
            
            playMissileSound(ctx, now) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
                gain.gain.setValueAtTime(0.4 * this.sfxVolume, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
                setTimeout(() => this.playSFX('explosion'), 300);
            }
            
            playPowerupSound(ctx, now) {
                [262, 330, 392, 523].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.frequency.setValueAtTime(freq, now + 0.08 * i);
                    gain.gain.setValueAtTime(0.3 * this.sfxVolume, now + 0.08 * i);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08 * i + 0.2);
                    osc.start(now + 0.08 * i);
                    osc.stop(now + 0.08 * i + 0.2);
                });
            }
            
            playUpgradeSound(ctx, now) {
                [440, 554, 659, 880].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.frequency.setValueAtTime(freq, now + 0.1 * i);
                    gain.gain.setValueAtTime(0.25 * this.sfxVolume, now + 0.1 * i);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1 * i + 0.3);
                    osc.start(now + 0.1 * i);
                    osc.stop(now + 0.1 * i + 0.3);
                });
            }
            
            playWarningSound(ctx, now) {
                for (let i = 0; i < 3; i++) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'square';
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    const freq = i % 2 === 0 ? 440 : 554;
                    osc.frequency.setValueAtTime(freq, now + 0.2 * i);
                    gain.gain.setValueAtTime(0.3 * this.sfxVolume, now + 0.2 * i);
                    gain.gain.setValueAtTime(0, now + 0.2 * i + 0.15);
                    osc.start(now + 0.2 * i);
                    osc.stop(now + 0.2 * i + 0.15);
                }
            }
            
            playWaveCompleteSound(ctx, now) {
                [523, 659, 784, 1047].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.frequency.setValueAtTime(freq, now + 0.15 * i);
                    gain.gain.setValueAtTime(0.3 * this.sfxVolume, now + 0.15 * i);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15 * i + 0.4);
                    osc.start(now + 0.15 * i);
                    osc.stop(now + 0.15 * i + 0.4);
                });
            }
            
            setMusicVolume(vol) {
                this.musicVolume = Math.max(0, Math.min(1, vol));
                if (this.currentMusic) this.currentMusic.volume = this.muted ? 0 : this.musicVolume;
            }
            
            setSFXVolume(vol) {
                this.sfxVolume = Math.max(0, Math.min(1, vol));
            }
            
            toggleMute() {
                this.muted = !this.muted;
                if (this.currentMusic) this.currentMusic.volume = this.muted ? 0 : this.musicVolume;
                return this.muted;
            }
        }
        
        let audioManager;
        
        function initAudioSystem() {
            audioManager = new AudioManager();
            document.getElementById('audioControls').style.display = 'flex';
        }
        
        function toggleAudio() {
            if (!audioManager) return;
            const muted = audioManager.toggleMute();
            const btn = document.getElementById('muteBtn');
            btn.textContent = muted ? '🔇' : '🔊';
            btn.classList.toggle('muted', muted);
        }
        
        window.addEventListener('load', () => {
            initAudioSystem();
        });
        
        window.addEventListener('error', (e) => {
            console.error('Game Error:', e.error);
            if (e.error && e.error.stack) console.error('Stack:', e.error.stack);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled Promise Rejection:', e.reason);
            e.preventDefault();
        });
        
        let performanceMetrics = {
            frameDrops: 0,
            lastFrameTime: performance.now(),
            avgFrameTime: 16.67
        };
        
        function monitorPerformance(dt) {
            const frameTime = dt * 1000;
            performanceMetrics.avgFrameTime = performanceMetrics.avgFrameTime * 0.95 + frameTime * 0.05;
            if (frameTime > 33) {
                performanceMetrics.frameDrops++;
                if (performanceMetrics.frameDrops > 10) {
                    console.warn('Performance degradation detected.');
                }
            }
        }

        let Game = null;
        
        function initializeGame() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            const CONFIG = {
                ORBIT_RADIUS: 60,
                MAX_WAVES: 20,
                INITIAL_LIVES: 3,
                INITIAL_COINS: 100,
                INITIAL_MISSILES: 3,
                MAX_PARTICLES: 500,
                PARTICLE_MULTIPLIER: 1.0,
                SPATIAL_GRID_CELL_SIZE: 150,
                AUTO_FIRE_BASE_RATE: 400,
                COMBO_TIMEOUT: 3,
                STUCK_TIMER_DURATION: 3,
                HIT_PAUSE_DURATION: 0.05,
                HIT_PAUSE_SCALE: 0.3,
                SCREEN_SHAKE_DAMPENING: 0.85,
                ENEMY_HIT_RADIUS: 25,
                BOSS_HIT_RADIUS: 80,
                MISSILE_SEARCH_RADIUS: 100,
                DIFFICULTY: {
                    easy: { enemyHealth: 0.7, enemySpeed: 0.7, enemyCount: 0.8, coinMultiplier: 1.2 },
                    normal: { enemyHealth: 1.0, enemySpeed: 1.0, enemyCount: 1.0, coinMultiplier: 1.0 },
                    hard: { enemyHealth: 1.3, enemySpeed: 1.5, enemyCount: 1.5, coinMultiplier: 0.8 }
                },
                SHIP_SIZE: 58,
                ENEMY_SIZE_BASE: 60,
                BOSS_SIZE_BASE: 150,
                SHIELD_RADIUS: 70,
                DEBUG_MODE: false,
                SHOW_FPS: false,
                SHOW_HITBOXES: false,
                GOD_MODE: false
            };
            
            const isMobile = /iPhone|iPad|Android/i.test(navigator.userAgent);
            if (isMobile) {
                CONFIG.MAX_PARTICLES = 250;
                CONFIG.PARTICLE_MULTIPLIER = 0.5;
            }
            
            const orbitRadius = CONFIG.ORBIT_RADIUS;
            const maxWaves = CONFIG.MAX_WAVES;
            
            let wave = 1, lives = CONFIG.INITIAL_LIVES, coins = CONFIG.INITIAL_COINS, score = 0, missiles = CONFIG.INITIAL_MISSILES;
            let shipAngle = 0, targetAngle = 0;
            let shipX = 0, shipY = 0;
            let gameRunning = false, isPaused = false, lastFrameTime = 0;
            let screenShake = 0, autoFireTimer = 0, comboCount = 0, comboTimer = 0;
            let waitingForNextWave = false, showingWaveChoice = false;
            let currentWaveModifier = null, shopReturnState = 'menu';
            let shotsFired = 0, shotsHit = 0;
            let difficulty = 'normal';
            let highScore = 0;
            let stuckTimer = 0;
            let burstCounter = 0;
            let hitPauseTimer = 0;
            let timeScale = 1.0;
            
            function triggerHitPause(duration = CONFIG.HIT_PAUSE_DURATION, scale = CONFIG.HIT_PAUSE_SCALE) {
                hitPauseTimer = Math.max(hitPauseTimer, duration);
                timeScale = scale;
            }
            
            function updateHitPause(dt) {
                if (hitPauseTimer > 0) {
                    hitPauseTimer -= dt;
                    if (hitPauseTimer <= 0) {
                        timeScale = 1.0;
                    }
                }
            }
            
            let powerUps = [];
            let activeEffects = { overdrive: 0, gravityBomb: 0 };
            let survivalMode = false;
            let survivalTimer = 0;
            let survivalKills = 0;
            let closeKillBonus = 0;
            let perfectWaveBonus = true;
            let grazeBonus = 0;
            
            let playAreaBounds = { left: 0, top: 0, right: 0, bottom: 0 };
            let visualEarthX = canvas.width / 2;
            let visualEarthY = canvas.height / 2;
            let earthCenterX = visualEarthX;
            let earthCenterY = visualEarthY;
            
            let gameState = {};
            const defaultGameState = {
                equipment: { weapon: 'basic', shield: null, system: null },
                owned: { weapons: ['basic'], shields: [], systems: [] },
                maxShieldHealth: 0,
                shieldHealth: 0,
                temporaryUpgrades: []
            };
            
            const deathStats = {
                waveReached: 1,
                enemiesKilled: 0,
                coinsEarned: 0,
                accuracy: '0%'
            };
            
            let projectiles = [], enemies = [], particles = [], explosions = [], missileProjectiles = [];
            let bossProjectiles = [];
            let damageNumbers = [];
            let beamEffects = [];
            let plasmaWaves = [];
            
            const backgroundImg = new Image();
            backgroundImg.src = 'assets/background.png';
            let backgroundLoaded = false;
            backgroundImg.onload = () => {
                backgroundLoaded = true;
                resizeCanvas();
            };
            backgroundImg.onerror = () => {
                console.warn('Background image failed to load - using fallback');
                backgroundLoaded = false;
                resizeCanvas();
            };
            
            const playerShipImg = new Image();
            playerShipImg.src = 'assets/IMG_1521.jpg';
            let playerShipLoaded = false;
            playerShipImg.onload = () => playerShipLoaded = true;
            playerShipImg.onerror = () => console.warn('Player ship image failed to load');
            
            const playerShipDamagedImg = new Image();
            playerShipDamagedImg.src = 'assets/player-ship-damaged.jpg';
            let playerShipDamagedLoaded = false;
            playerShipDamagedImg.onload = () => playerShipDamagedLoaded = true;
            playerShipDamagedImg.onerror = () => console.warn('Damaged ship image failed to load');
            
            const bossProjectileImg1 = new Image();
            bossProjectileImg1.src = 'assets/IMG_1441 2.jpg';
            bossProjectileImg1.onerror = () => console.warn('Boss projectile 1 failed to load');
            
            const bossProjectileImg2 = new Image();
            bossProjectileImg2.src = 'assets/IMG_1439 2.jpg';
            bossProjectileImg2.onerror = () => console.warn('Boss projectile 2 failed to load');
            
            const enemyImagePaths = [
                "assets/IMG_1505.jpg", "assets/IMG_1506.jpg", "assets/IMG_1508.jpg",
                "assets/IMG_1510.jpg", "assets/IMG_1511.jpg", "assets/IMG_1512.jpg",
                "assets/IMG_1513.jpg", "assets/IMG_1514.jpg", "assets/IMG_1515.jpg",
                "assets/IMG_1517.jpg"
            ];
            const enemyImages = {};
            
            class AssetPreloader {
                constructor() {
                    this.assets = [];
                    this.loaded = 0;
                    this.total = 0;
                    this.onProgress = null;
                    this.onComplete = null;
                }
                
                addImage(src, id = null) {
                    this.assets.push({ type: 'image', src, id });
                    this.total++;
                }
                
                addAudio(src, id = null) {
                    this.assets.push({ type: 'audio', src, id });
                    this.total++;
                }
                
                async load() {
                    const promises = this.assets.map(asset => {
                        if (asset.type === 'image') {
                            return this.loadImage(asset.src, asset.id);
                        } else if (asset.type === 'audio') {
                            return this.loadAudio(asset.src, asset.id);
                        }
                    });
                    await Promise.all(promises);
                    if (this.onComplete) this.onComplete();
                }
                
                loadImage(src, id) {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            this.loaded++;
                            if (this.onProgress) this.onProgress(this.loaded, this.total);
                            resolve({ img, id, src });
                        };
                        img.onerror = () => {
                            console.warn(`Failed to load image: ${src}`);
                            this.loaded++;
                            if (this.onProgress) this.onProgress(this.loaded, this.total);
                            resolve(null);
                        };
                        img.src = src;
                    });
                }
                
                loadAudio(src, id) {
                    return new Promise((resolve) => {
                        const audio = new Audio(src);
                        audio.preload = 'auto';
                        audio.oncanplaythrough = () => {
                            this.loaded++;
                            if (this.onProgress) this.onProgress(this.loaded, this.total);
                            resolve({ audio, id, src });
                        };
                        audio.onerror = () => {
                            console.warn(`Failed to load audio: ${src}`);
                            this.loaded++;
                            if (this.onProgress) this.onProgress(this.loaded, this.total);
                            resolve(null);
                        };
                        audio.load();
                    });
                }
                
                getProgress() {
                    return this.total > 0 ? this.loaded / this.total : 0;
                }
            }
            
            function preloadEnemyImages() {
                enemyImagePaths.forEach(path => {
                    const img = new Image();
                    img.src = path;
                    img.onload = () => enemyImages[path] = img;
                    img.onerror = () => console.warn(`Failed to load enemy image: ${path}`);
                });
            }

            const shopItems = {
                weapons: [
                    {id: "basic", name: "Basic Cannon", cost: 0, damage: 1, fireRate: 400, desc: "Standard issue.", sprite: "assets/IMG_1426 2.JPG"},
                    {id: "spread", name: "Spread Shot", cost: 250, damage: 0.8, fireRate: 450, desc: "Fires 5 projectiles in a fan pattern.", pattern: "spread", sprite: "assets/IMG_1405 2.JPG"},
                    {id: "piercing", name: "Rail Gun", cost: 500, damage: 5, fireRate: 1000, desc: "Instant beam that pierces all enemies.", beam: true, piercing: true, sprite: "assets/IMG_1408 2.JPG"},
                    {id: "rapid", name: "Rapid Fire", cost: 800, damage: 0.5, fireRate: 100, desc: "Continuous stream of bullets.", rapid: true, sprite: "assets/IMG_1403 2.JPG"},
                    {id: "burst", name: "Burst Cannon", cost: 1200, damage: 1.5, fireRate: 600, desc: "Fires 3-shot bursts.", burst: 3, sprite: "assets/IMG_1404 2.JPG"},
                    {id: "plasma", name: "Plasma Wave", cost: 2000, damage: 3, fireRate: 800, desc: "Expanding energy wave hits multiple targets.", wave: true, sprite: "assets/IMG_1429 2.JPG"}
                ],
                shields: [
                    {id: "basic", name: "Energy Shield", cost: 300, health: 100, desc: "Absorbs 100 damage.", sprite: "assets/IMG_1424 2.JPG"},
                    {id: "regen", name: "Regen Shield", cost: 700, health: 80, regen: 2, desc: "Regenerates 2 HP per second.", sprite: "assets/IMG_1423 2.JPG"},
                    {id: "reflect", name: "Reflect Shield", cost: 1000, health: 100, reflect: 0.4, desc: "40% chance to destroy enemies on contact.", sprite: "assets/IMG_1421 2.JPG"},
                    {id: "absorb", name: "Absorb Shield", cost: 1500, health: 150, absorb: true, desc: "Converts damage into coins.", sprite: "assets/IMG_1409 2.JPG"}
                ],
                systems: [
                    {id: "speed", name: "Thrusters", cost: 300, speedBoost: 1.5, desc: "50% faster ship rotation.", sprite: "assets/IMG_1422 2.JPG"},
                    {id: "auto", name: "Auto-Targeter", cost: 600, autoTarget: true, desc: "Automatically aims at nearest enemy.", sprite: "assets/IMG_1416 2.JPG"},
                    {id: "slowmo", name: "Time Dilation", cost: 900, slowmo: 0.6, desc: "Enemies move 40% slower.", sprite: "assets/IMG_1447 2.JPG"},
                    {id: "multilock", name: "Multi-Lock", cost: 1500, multiTarget: 3, desc: "Missiles track 3 targets simultaneously.", sprite: "assets/IMG_1445 2.JPG"}
                ]
            };
            
            const waveModifiers = [
                {id: "speed", name: "Speed Wave", desc: "Enemies move 2x faster!", speedMultiplier: 2, color: "#3b82f6"},
                {id: "swarm", name: "Swarm Wave", desc: "3x more enemies!", enemyMultiplier: 3, color: "#10b981"},
                {id: "boss", name: "Boss Wave", desc: "One massive enemy!", bossWave: true, color: "#ef4444"},
                {id: "armored", name: "Armored Wave", desc: "Enemies have 2x health!", healthMultiplier: 2, color: "#f59e0b"},
                {id: "fast-spawn", name: "Siege Wave", desc: "Enemies spawn closer!", spawnDistance: 0.5, color: "#8b5cf6"}
            ];
            
            class SpatialGrid {
                constructor(cellSize = 100) {
                    this.cellSize = cellSize;
                    this.grid = new Map();
                }
                
                clear() {
                    this.grid.clear();
                }
                
                _getCellKey(x, y) {
                    const cellX = Math.floor(x / this.cellSize);
                    const cellY = Math.floor(y / this.cellSize);
                    return `${cellX},${cellY}`;
                }
                
                insert(entity) {
                    if (!entity || entity.x === undefined || entity.y === undefined) return;
                    const key = this._getCellKey(entity.x, entity.y);
                    if (!this.grid.has(key)) {
                        this.grid.set(key, []);
                    }
                    this.grid.get(key).push(entity);
                }
                
                getNearby(x, y, radius) {
                    const nearby = [];
                    const cellRadius = Math.ceil(radius / this.cellSize);
                    const centerX = Math.floor(x / this.cellSize);
                    const centerY = Math.floor(y / this.cellSize);
                    for (let dx = -cellRadius; dx <= cellRadius; dx++) {
                        for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                            const key = `${centerX + dx},${centerY + dy}`;
                            if (this.grid.has(key)) {
                                nearby.push(...this.grid.get(key));
                            }
                        }
                    }
                    return nearby;
                }
                
                getAllEntities() {
                    const all = [];
                    for (const entities of this.grid.values()) {
                        all.push(...entities);
                    }
                    return all;
                }
            }
            
            const enemyGrid = new SpatialGrid(150);
            const projectileGrid = new SpatialGrid(100);
            const bossProjectileGrid = new SpatialGrid(100);
            
            class ObjectPool {
                constructor(createFn, resetFn, initialSize = 50) {
                    this.createFn = createFn;
                    this.resetFn = resetFn;
                    this.pool = [];
                    this.active = [];
                    for (let i = 0; i < initialSize; i++) {
                        this.pool.push(this.createFn());
                    }
                }
                
                get(...args) {
                    let obj = this.pool.pop();
                    if (!obj) {
                        obj = this.createFn();
                    }
                    this.resetFn(obj, ...args);
                    this.active.push(obj);
                    return obj;
                }
                
                release(obj) {
                    const index = this.active.indexOf(obj);
                    if (index > -1) {
                        this.active.splice(index, 1);
                        this.pool.push(obj);
                    }
                }
                
                releaseAll() {
                    this.pool.push(...this.active);
                    this.active = [];
                }
                
                getActive() {
                    return this.active;
                }
                
                getActiveCount() {
                    return this.active.length;
                }
            }
            
            const particlePool = new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, color: '#fff', lifetime: 1, maxLifetime: 1, size: 2 }),
                (p, x, y, vx, vy, color, lifetime, size = 2) => {
                    p.x = x;
                    p.y = y;
                    p.vx = vx;
                    p.vy = vy;
                    p.color = color;
                    p.lifetime = lifetime;
                    p.maxLifetime = lifetime;
                    p.size = size + Math.random() * size;
                },
                isMobile ? 250 : 500
            );
            
            const projectilePool = new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, damage: 1, piercing: false, life: 3, maxLife: 3, weaponType: 'basic' }),
                (p, x, y, vx, vy, damage, piercing, weaponType) => {
                    p.x = x;
                    p.y = y;
                    p.vx = vx;
                    p.vy = vy;
                    p.damage = damage;
                    p.piercing = piercing;
                    p.life = 3;
                    p.maxLife = 3;
                    p.weaponType = weaponType;
                },
                100
            );
            
            const missilePool = new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, target: null, life: 5, damage: 10 }),
                (m, x, y, vx, vy, target) => {
                    m.x = x;
                    m.y = y;
                    m.vx = vx;
                    m.vy = vy;
                    m.target = target;
                    m.life = 5;
                    m.damage = 10;
                },
                20
            );
            
            const bossProjectilePool = new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, damage: 1, spritePath: null, rotation: 0 }),
                (bp, x, y, vx, vy, damage) => {
                    bp.x = x;
                    bp.y = y;
                    bp.vx = vx;
                    bp.vy = vy;
                    bp.damage = damage;
                    bp.rotation = 0;
                },
                50
            );
            
            class DamageNumberSystem {
                constructor() {
                    this.numbers = [];
                }
                
                add(x, y, damage) {
                    if (this.numbers.length > 50) return;
                    this.numbers.push({
                        x, y, damage,
                        lifetime: 1.0,
                        offsetY: 0,
                        alpha: 1.0
                    });
                }
                
                update(dt) {
                    for (let i = this.numbers.length - 1; i >= 0; i--) {
                        const dn = this.numbers[i];
                        if (!dn) continue;
                        dn.lifetime -= dt;
                        dn.offsetY -= 30 * dt;
                        dn.alpha = Math.max(0, dn.lifetime);
                        if (dn.lifetime <= 0) {
                            this.numbers.splice(i, 1);
                        }
                    }
                }
                
                draw(ctx) {
                    ctx.save();
                    ctx.font = 'bold 18px "JetBrains Mono", monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    this.numbers.forEach(dn => {
                        if (!dn) return;
                        ctx.globalAlpha = dn.alpha;
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 3;
                        ctx.fillStyle = '#ff4444';
                        const text = `-${Math.floor(dn.damage)}`;
                        ctx.strokeText(text, dn.x, dn.y + dn.offsetY);
                        ctx.fillText(text, dn.x, dn.y + dn.offsetY);
                    });
                    ctx.restore();
                }
            }
            
            const damageNumberSystem = new DamageNumberSystem();
            
            const ArrayUtils = {
                safeGet: (array, index, defaultValue = null) => {
                    return (array && index >= 0 && index < array.length) ? array[index] : defaultValue;
                },
                fastRemove: (array, index) => {
                    if (index >= 0 && index < array.length) {
                        const last = array.length - 1;
                        if (index < last) {
                            array[index] = array[last];
                        }
                        array.pop();
                    }
                },
                fastClear: (array) => {
                    array.length = 0;
                },
                filterInPlace: (array, predicate) => {
                    let writeIndex = 0;
                    for (let i = 0; i < array.length; i++) {
                        if (predicate(array[i], i, array)) {
                            if (writeIndex !== i) {
                                array[writeIndex] = array[i];
                            }
                            writeIndex++;
                        }
                    }
                    array.length = writeIndex;
                    return array;
                }
            };
            
            function isInBounds(x, y) {
                return x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height;
            }
            
            function clampToBounds(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }
            
            function isInPlayArea(x, y) {
                if (!playAreaBounds || !playAreaBounds.left) return true;
                return x >= playAreaBounds.left && 
                       x <= playAreaBounds.right && 
                       y >= playAreaBounds.top && 
                       y <= playAreaBounds.bottom;
            }
            
            class Particle {
                constructor(x, y, vx, vy, color, lifetime, size = 2) {
                    this.x = x;
                    this.y = y;
                    this.vx = vx;
                    this.vy = vy;
                    this.color = color;
                    this.lifetime = lifetime;
                    this.maxLifetime = lifetime;
                    this.size = size + Math.random() * size;
                    this.active = true;
                }
                
                update(dt) {
                    this.x += this.vx * dt * 60;
                    this.y += this.vy * dt * 60;
                    this.vy += 0.5;
                    this.lifetime -= dt;
                }
                
                draw(ctx) {
                    const alpha = this.lifetime / this.maxLifetime;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
                
                isDead() {
                    return this.lifetime <= 0;
                }
            }
            
            function createExplosion(x, y, count, color, intensity = 1, isBoss = false) {
                const flameColors = ['#ff6b00', '#ff8c00', '#ffa500', '#ffb347', '#ff4500', '#dc143c'];
                const baseCount = Math.floor(count * CONFIG.PARTICLE_MULTIPLIER);
                const particleCount = isBoss ? baseCount * 3 : baseCount;
                const maxParticles = CONFIG.MAX_PARTICLES;
                for (let i = 0; i < particleCount && particles.length < maxParticles; i++) {
                    const angle = 2 * Math.PI / particleCount * i + (Math.random() - 0.5) * 0.5;
                    const speed = (3 + 4 * Math.random()) * intensity * (isBoss ? 1.5 : 1);
                    const particleColor = flameColors[Math.floor(Math.random() * flameColors.length)];
                    const particle = particlePool.get(
                        x, y,
                        Math.cos(angle) * speed, Math.sin(angle) * speed,
                        particleColor,
                        0.8 + 0.7 * Math.random(),
                        isBoss ? 2 : 1
                    );
                    particles.push(particle);
                }
                screenShake = Math.min(screenShake + count * 0.8 * intensity * (isBoss ? 2 : 1), 20);
                if (isBoss) {
                    vibrate(100);
                    setTimeout(() => vibrate(50), 100);
                    setTimeout(() => vibrate(150), 200);
                } else {
                    vibrate(Math.min(50 * intensity, 100));
                }
            }
            
            function vibrate(duration) {
                if ('vibrate' in navigator) {
                    navigator.vibrate(duration);
                }
            }
            
            class CanvasDamageNumber {
                constructor(x, y, damage) {
                    this.x = x;
                    this.y = y;
                    this.damage = damage;
                    this.lifetime = 1.0;
                    this.offsetY = 0;
                    this.alpha = 1.0;
                }
                
                update(dt) {
                    this.lifetime -= dt;
                    this.offsetY -= 50 * dt;
                    this.alpha = Math.max(0, this.lifetime);
                    return this.lifetime > 0;
                }
                
                draw(ctx) {
                    ctx.save();
                    ctx.globalAlpha = this.alpha;
                    ctx.font = 'bold 20px JetBrains Mono';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 4;
                    ctx.fillStyle = '#ff4444';
                    const text = `-${Math.floor(this.damage)}`;
                    const drawY = this.y + this.offsetY;
                    ctx.strokeText(text, this.x, drawY);
                    ctx.fillText(text, this.x, drawY);
                    ctx.restore();
                }
            }
            
            let canvasDamageNumbers = [];
            
            function showDamageNumber(x, y, damage) {
                if (canvasDamageNumbers.length > 50) return;
                canvasDamageNumbers.push(new CanvasDamageNumber(x, y, damage));
            }
            
            function updateDamageNumbers(dt) {
                canvasDamageNumbers = canvasDamageNumbers.filter(dn => dn && dn.update(dt));
            }
            
            function drawDamageNumbers(ctx) {
                canvasDamageNumbers.forEach(dn => dn && dn.draw(ctx));
            }
            
            function addCombo() {
                comboCount++;
                comboTimer = 3;
                updateComboDisplay();
                if (comboCount % 5 === 0) {
                    coins += 2 * comboCount;
                    score += 10 * comboCount;
                }
            }
            
            function updateComboDisplay() {
                const el = document.getElementById("comboCounter");
                if (!el) return;
                if (comboCount > 1) {
                    el.textContent = `${comboCount}x Combo!`;
                    el.style.fontSize = `${Math.min(1.5 + 0.1 * comboCount, 2.5)}rem`;
                    el.style.opacity = "1";
                } else {
                    el.style.opacity = "0";
                }
            }

            function init() {
                preloadEnemyImages();
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                loadGameState();
                setupControls();
                renderShop('weapons');
            }

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                cachedEarthPosition = null;
                calculatePlayArea();
                calculateEarthPosition();
                positionUIElements();
                drawBackground();
            }
            
            function positionUIElements() {
                if (!playAreaBounds || !playAreaBounds.left) return;
                
                const hud = document.getElementById('hud');
                const missileBtn = document.getElementById('missileButton');
                const titleImg = document.getElementById('titleImage');
                const menu = document.getElementById('menu');
                const shop = document.getElementById('shop');
                const waveChoice = document.getElementById('waveChoice');
                const waveTransition = document.getElementById('waveTransition');
                const deathScreen = document.getElementById('deathScreen');
                const victoryScreen = document.getElementById('victoryScreen');
                
                if (hud) {
                    hud.style.left = playAreaBounds.left + 'px';
                    hud.style.right = (canvas.width - playAreaBounds.right) + 'px';
                    hud.style.top = playAreaBounds.top + 'px';
                    hud.style.width = (playAreaBounds.right - playAreaBounds.left) + 'px';
                }
                
                if (missileBtn) {
                    missileBtn.style.right = (canvas.width - playAreaBounds.right + 16) + 'px';
                    missileBtn.style.bottom = (canvas.height - playAreaBounds.bottom + 16) + 'px';
                }
                
                if (titleImg) {
                    const bgWidth = playAreaBounds.right - playAreaBounds.left;
                    titleImg.style.maxWidth = Math.min(400, bgWidth * 0.8) + 'px';
                    titleImg.style.left = (playAreaBounds.left + bgWidth / 2) + 'px';
                    titleImg.style.top = (playAreaBounds.top + 200) + 'px';
                }
                
                // Position all menus within background bounds (except main menu which has its own CSS)
                const bgCenterX = playAreaBounds.left + (playAreaBounds.right - playAreaBounds.left) / 2;
                const bgCenterY = playAreaBounds.top + (playAreaBounds.bottom - playAreaBounds.top) / 2;
                const bgWidth = playAreaBounds.right - playAreaBounds.left;
                
                [shop, waveChoice, waveTransition, deathScreen, victoryScreen].forEach(el => {
                    if (el) {
                        el.style.left = bgCenterX + 'px';
                        el.style.top = bgCenterY + 'px';
                        el.style.maxWidth = Math.min(800, bgWidth * 0.85) + 'px';
                    }
                });
            }

            function calculatePlayArea() {
                if (!backgroundLoaded || !backgroundImg.width) return;
                const canvasAspect = canvas.width / canvas.height;
                const imgAspect = backgroundImg.width / backgroundImg.height;
                let width, height, x, y;
                if (canvasAspect > imgAspect) {
                    height = canvas.height;
                    width = height * imgAspect;
                    y = 0;
                    x = (canvas.width - width) / 2;
                } else {
                    width = canvas.width;
                    height = width / imgAspect;
                    x = 0;
                    y = (canvas.height - height) / 2;
                }
                playAreaBounds = {
                    left: x + 20,
                    top: y + 20,
                    right: x + width - 20,
                    bottom: y + height - 20
                };
                visualEarthX = x + width / 2;
                visualEarthY = y + height / 2;
                earthCenterX = visualEarthX;
                earthCenterY = visualEarthY;
            }

            function loadGameState() {
                try {
                    const savedHighScore = localStorage.getItem('earthDefenderHighScore');
                    highScore = savedHighScore ? parseInt(savedHighScore, 10) : 0;
                } catch (e) {
                    console.warn('Failed to load high score:', e);
                    highScore = 0;
                }
                try {
                    const saved = localStorage.getItem("earthDefenderSave");
                    if (saved) {
                        const data = JSON.parse(saved);
                        if (data.version && data.version !== GAME_VERSION) {
                            console.warn('Save version mismatch, resetting...');
                            gameState = JSON.parse(JSON.stringify(defaultGameState));
                            coins = CONFIG.INITIAL_COINS;
                        } else {
                            gameState = data.gameState || JSON.parse(JSON.stringify(defaultGameState));
                            coins = data.coins || CONFIG.INITIAL_COINS;
                        }
                    } else {
                        gameState = JSON.parse(JSON.stringify(defaultGameState));
                        coins = CONFIG.INITIAL_COINS;
                    }
                } catch (error) {
                    console.error('Failed to load game state, resetting:', error);
                    gameState = JSON.parse(JSON.stringify(defaultGameState));
                    coins = CONFIG.INITIAL_COINS;
                }
            }
            
            function saveGameState() {
                try {
                    highScore = Math.max(highScore, score);
                    localStorage.setItem('earthDefenderHighScore', highScore.toString());
                    localStorage.setItem("earthDefenderSave", JSON.stringify({
                        version: GAME_VERSION,
                        gameState,
                        coins
                    }));
                } catch (e) {
                    console.error('Failed to save game state:', e);
                }
            }
            
            function setupControls() {
                let isDragging = false;
                let touchStartX = 0;
                canvas.addEventListener('mousemove', (e) => {
                    if (!gameRunning || isPaused) return;
                    const rect = canvas.getBoundingClientRect();
                    targetAngle = Math.atan2(e.clientY - rect.top - earthCenterY, e.clientX - rect.left - earthCenterX);
                });
                canvas.addEventListener('touchstart', (e) => {
                    if (!gameRunning || isPaused) return;
                    e.preventDefault();
                    isDragging = true;
                    touchStartX = e.touches[0].clientX;
                }, { passive: false });
                canvas.addEventListener('touchmove', (e) => {
                    if (!gameRunning || isPaused || !isDragging) return;
                    e.preventDefault();
                    const touchX = e.touches[0].clientX;
                    const delta = (touchX - touchStartX) / canvas.width;
                    const sensitivity = Math.min(3, 2 * (window.devicePixelRatio || 1));
                    targetAngle += delta * sensitivity;
                    touchStartX = touchX;
                }, { passive: false });
                canvas.addEventListener('touchend', () => isDragging = false);
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        isPaused = !isPaused;
                        const display = isPaused ? 'flex' : 'none';
                        document.getElementById('pauseScreen').style.display = display;
                        if (audioManager) {
                            if (isPaused) {
                                audioManager.stopMusic(500);
                            } else {
                                audioManager.playMusic(isBossWave() ? 'boss' : 'gameplay');
                            }
                        }
                    }
                    if (!gameRunning || isPaused) return;
                    if (e.key === 'ArrowLeft' || e.key === 'a') targetAngle -= 0.1;
                    else if (e.key === 'ArrowRight' || e.key === 'd') targetAngle += 0.1;
                    else if (e.key === ' ') {
                        e.preventDefault();
                        Game.launchMissile();
                    }
                });
            }

            function setDifficulty(level) {
                difficulty = level;
            }

            function startGame(level = 'normal') {
                setDifficulty(level);
                if (audioManager) audioManager.playMusic('gameplay', 1500);
                shopReturnState = 'menu';
                isPaused = false;
                document.getElementById('menu').style.display = 'none';
                document.getElementById('titleImage').style.display = 'none';
                document.getElementById('hud').style.display = 'flex';
                document.getElementById('missileButton').style.display = 'block';
                gameRunning = true;
                wave = 1;
                lives = CONFIG.INITIAL_LIVES;
                score = 0;
                missiles = CONFIG.INITIAL_MISSILES;
                comboCount = 0;
                shotsFired = 0;
                shotsHit = 0;
                waitingForNextWave = false;
                showingWaveChoice = false;
                stuckTimer = 0;
                burstCounter = 0;
                loadGameState();
                gameState.temporaryUpgrades = [];
                enemies = [];
                projectiles = [];
                particles = [];
                missileProjectiles = [];
                bossProjectiles = [];
                beamEffects = [];
                plasmaWaves = [];
                deathStats.waveReached = 1;
                deathStats.enemiesKilled = 0;
                deathStats.coinsEarned = coins;
                lastFrameTime = performance.now();
                updateUI();
                spawnWave();
                requestAnimationFrame(gameLoop);
            }

            let fps = 60, frameCount = 0, lastFpsUpdate = 0;
            const DEBUG_MODE = false;
            
            function updateFPS(now) {
                frameCount++;
                if (now - lastFpsUpdate >= 1000) {
                    fps = frameCount;
                    frameCount = 0;
                    lastFpsUpdate = now;
                    if (DEBUG_MODE) {
                        const fpsEl = document.getElementById('fpsCounter');
                        if (fpsEl) {
                            fpsEl.textContent = `FPS: ${fps}`;
                            fpsEl.style.display = 'block';
                            fpsEl.style.color = fps >= 60 ? '#0f0' : fps >= 30 ? '#ff0' : '#f00';
                        }
                    }
                }
            }
            
            function gameLoop(now) {
                requestAnimationFrame(gameLoop);
                updateFPS(now);
                if (isPaused) {
                    drawBackground();
                    drawShield();
                    drawShip();
                    return;
                }
                if (!now) now = performance.now();
                let dt = Math.min((now - lastFrameTime) / 1000, 0.0167);
                updateHitPause(dt);
                dt *= timeScale;
                lastFrameTime = now;
                drawBackground();

                if (!gameRunning && !showingWaveChoice) {
                    drawShield();
                    drawShip();
                    updateParticles(dt);
                    return;
                }

                ctx.save();
                
                // Clip everything to the background image area with extra buffer for large sprites
                if (playAreaBounds && playAreaBounds.left !== undefined) {
                    const bufferSize = 200; // Extra space for large sprites like bosses
                    ctx.beginPath();
                    ctx.rect(
                        playAreaBounds.left - bufferSize,
                        playAreaBounds.top - bufferSize,
                        (playAreaBounds.right - playAreaBounds.left) + (bufferSize * 2),
                        (playAreaBounds.bottom - playAreaBounds.top) + (bufferSize * 2)
                    );
                    ctx.clip();
                }
                
                if (screenShake > 0.1) {
                    const shakeX = (Math.random() - 0.5) * screenShake;
                    const shakeY = (Math.random() - 0.5) * screenShake;
                    const shakeRotation = (Math.random() - 0.5) * (screenShake * 0.002);
                    ctx.translate(canvas.width/2, canvas.height/2);
                    ctx.rotate(shakeRotation);
                    ctx.translate(-canvas.width/2 + shakeX, -canvas.height/2 + shakeY);
                    screenShake *= CONFIG.SCREEN_SHAKE_DAMPENING;
                } else if (screenShake > 0) {
                    screenShake = 0;
                }
                
                drawShield();
                drawShip();
                updateBeamEffects(dt);
                updatePlasmaWaves(dt);
                updateProjectiles(dt);
                updateMissiles(dt);
                updateBossProjectiles(dt);
                updateEnemies(dt);
                updateParticles(dt);
                updateDamageNumbers(dt);
                updateExplosions(dt);
                drawDamageNumbers(ctx);
                autoFire(dt);
                checkCollisions();

                const shield = shopItems.shields.find(s => s.id === gameState.equipment.shield);
                if (shield && shield.regen && gameState.shieldHealth < gameState.maxShieldHealth) {
                    gameState.shieldHealth = Math.min(gameState.shieldHealth + shield.regen * dt, gameState.maxShieldHealth);
                }
                
                const system = shopItems.systems.find(s => s.id === gameState.equipment.system);
                if (system && system.autoTarget && enemies.length > 0) {
                    const nearestEnemy = enemies.reduce((nearest, enemy) => {
                        if (!enemy || !nearest) return enemy || nearest;
                        const dist = Math.hypot(enemy.x - shipX, enemy.y - shipY);
                        const nearestDist = Math.hypot(nearest.x - shipX, nearest.y - shipY);
                        return dist < nearestDist ? enemy : nearest;
                    }, enemies[0]);
                    if (nearestEnemy) {
                        targetAngle = Math.atan2(nearestEnemy.y - shipY, nearestEnemy.x - shipX);
                    }
                }
                
                const angleDiff = targetAngle - shipAngle;
                const normalizedDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
                const rotationSpeed = system && system.speedBoost ? 0.15 * system.speedBoost : 0.15;
                shipAngle += normalizedDiff * rotationSpeed;

                if (comboCount > 0) {
                    comboTimer -= dt;
                    if (comboTimer <= 0) {
                        comboCount = 0;
                        updateComboDisplay();
                    }
                }
                
                if (gameRunning && !waitingForNextWave && !showingWaveChoice && enemies.length === 0) {
                    stuckTimer += dt;
                    if (stuckTimer > STUCK_TIMER_THRESHOLD) {
                        stuckTimer = 0;
                        waitingForNextWave = true;
                        if (wave >= maxWaves) {
                            showVictoryScreen();
                            return;
                        }
                        wave++;
                        if (audioManager) audioManager.playSFX('waveComplete');
                        deathStats.waveReached = wave;
                        coins += wave * 50;
                        missiles = Math.min(missiles + 1, 10);
                        updateUI();
                        saveGameState();
                        showWaveChoiceScreen();
                    }
                } else {
                    stuckTimer = 0;
                }
                
                ctx.restore();
            }

            function isBossWave() {
                return wave > 0 && wave % 3 === 0;
            }

            let cachedEarthPosition = null;
            
            function calculateEarthPosition() {
                if (!backgroundLoaded) {
                    cachedEarthPosition = {
                        x: 0, y: 0, width: canvas.width, height: canvas.height,
                        earthX: canvas.width / 2 - 2, earthY: canvas.height * 0.48 - 6
                    };
                    return;
                }
                const canvasAspect = canvas.width / canvas.height;
                const imgAspect = backgroundImg.width / backgroundImg.height;
                let drawWidth, drawHeight, offsetX, offsetY;
                if (canvasAspect > imgAspect) {
                    drawHeight = canvas.height;
                    drawWidth = drawHeight * imgAspect;
                    offsetY = 0;
                    offsetX = (canvas.width - drawWidth) / 2;
                } else {
                    drawWidth = canvas.width;
                    drawHeight = drawWidth / imgAspect;
                    offsetX = 0;
                    offsetY = (canvas.height - drawHeight) / 2;
                }
                cachedEarthPosition = {
                    x: offsetX,
                    y: offsetY,
                    width: drawWidth,
                    height: drawHeight,
                    earthX: offsetX + drawWidth / 2 - 2,
                    earthY: offsetY + drawHeight * 0.48 - 6
                };
                visualEarthX = cachedEarthPosition.earthX;
                visualEarthY = cachedEarthPosition.earthY;
                earthCenterX = visualEarthX;
                earthCenterY = visualEarthY;
            }

            function drawBackground() {
                ctx.fillStyle = "#0a0e1a";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                if (!cachedEarthPosition) {
                    calculateEarthPosition();
                }
                if (backgroundLoaded && cachedEarthPosition) {
                    ctx.drawImage(
                        backgroundImg,
                        cachedEarthPosition.x,
                        cachedEarthPosition.y,
                        cachedEarthPosition.width,
                        cachedEarthPosition.height
                    );
                } else {
                    visualEarthX = canvas.width / 2;
                    visualEarthY = canvas.height / 2;
                    earthCenterX = visualEarthX;
                    earthCenterY = visualEarthY;
                }
            }
            
            function drawShield() {
                if (gameState.shieldHealth > 0 && gameState.maxShieldHealth > 0) {
                    const healthPercent = gameState.shieldHealth / gameState.maxShieldHealth;
                    const opacity = 0.15 + healthPercent * 0.35;
                    ctx.strokeStyle = `rgba(34, 211, 238, ${opacity})`;
                    ctx.lineWidth = 2.5;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(visualEarthX, visualEarthY, SHIELD_VISUAL_RADIUS, 0, Math.PI * 2);
                    ctx.stroke();
                    if (healthPercent > 0.66) {
                        ctx.strokeStyle = `rgba(34, 211, 238, ${opacity * 0.6})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(visualEarthX, visualEarthY, 55, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    if (healthPercent > 0.33) {
                        ctx.strokeStyle = `rgba(34, 211, 238, ${opacity * 0.4})`;
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.arc(visualEarthX, visualEarthY, 60, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.setLineDash([]);
                }
            }
            
            function drawShip() {
                shipX = earthCenterX + Math.cos(shipAngle) * orbitRadius;
                shipY = earthCenterY + Math.sin(shipAngle) * orbitRadius;
                ctx.save();
                ctx.translate(shipX, shipY);
                ctx.rotate(shipAngle + Math.PI/2);
                const size = CONFIG.SHIP_SIZE;
                const img = lives < 3 ? playerShipDamagedImg : playerShipImg;
                const loaded = lives < 3 ? playerShipDamagedLoaded : playerShipLoaded;
                if (loaded) {
                    ctx.globalCompositeOperation = "lighter";
                    ctx.drawImage(img, -size/2, -size/2, size, size);
                    ctx.globalCompositeOperation = "source-over";
                }
                ctx.restore();
            }

            function spawnWave() {
                waitingForNextWave = false;
                currentWaveModifier = null;
                if (isBossWave()) {
                    currentWaveModifier = waveModifiers.find(m => m.bossWave);
                } else if (wave > 1) {
                    const possibleMods = waveModifiers.filter(m => !m.bossWave);
                    currentWaveModifier = possibleMods[Math.floor(Math.random() * possibleMods.length)];
                }
                if (currentWaveModifier) {
                    showWaveModifier(currentWaveModifier);
                    if (currentWaveModifier.bossWave && audioManager) {
                        audioManager.playMusic('boss', 1000);
                    }
                } else if (audioManager && gameRunning) {
                    audioManager.playMusic('gameplay', 1000);
                }
                const enemyTypes = [
                    {name: "scout", health: 1, speed: 1.2, coins: 10, sprites: ["assets/IMG_1512.jpg", "assets/IMG_1514.jpg"]},
                    {name: "fighter", health: 2, speed: 0.8, coins: 15, sprites: ["assets/IMG_1505.jpg", "assets/IMG_1506.jpg"]},
                    {name: "tank", health: 4, speed: 0.5, coins: 25, sprites: ["assets/IMG_1508.jpg", "assets/IMG_1515.jpg", "assets/IMG_1517.jpg"]}
                ];
                const bossSprites = ["assets/IMG_1510.jpg", "assets/IMG_1511.jpg", "assets/IMG_1513.jpg"];
                const diffMult = CONFIG.DIFFICULTY[difficulty];
                let composition = [];
                let enemyCount = Math.round((5 + (wave - 1) * 2) * diffMult.enemyCount);
                if (currentWaveModifier && currentWaveModifier.bossWave) {
                    const bossData = {
                        name: 'boss',
                        health: (100 + wave * 15) * diffMult.enemyHealth,
                        speed: 0.3 * diffMult.enemySpeed,
                        coins: 200,
                        spritePath: bossSprites[Math.floor(Math.random() * bossSprites.length)],
                        canShoot: true,
                        shootRate: 2500
                    };
                    composition.push(bossData);
                    enemyCount = 0;
                }
                enemyCount *= currentWaveModifier && currentWaveModifier.enemyMultiplier ? currentWaveModifier.enemyMultiplier : 1;
                for (let i = 0; i < enemyCount; i++) {
                    composition.push(enemyTypes[Math.floor(Math.random() * enemyTypes.length)]);
                }
                composition.forEach((type) => {
                    const health = (type.health + (wave-1) * 0.2) * (currentWaveModifier && currentWaveModifier.healthMultiplier ? currentWaveModifier.healthMultiplier : 1) * diffMult.enemyHealth;
                    const speed = type.speed * (currentWaveModifier && currentWaveModifier.speedMultiplier ? currentWaveModifier.speedMultiplier : 1) * diffMult.enemySpeed;
                    const spawnAngle = Math.random() * Math.PI * 2;
                    
                    // Spawn at edge of background image, not canvas
                    const bgWidth = playAreaBounds.right - playAreaBounds.left;
                    const bgHeight = playAreaBounds.bottom - playAreaBounds.top;
                    const spawnDistance = Math.min(bgWidth, bgHeight) * 0.55;
                    
                    const startX = visualEarthX + Math.cos(spawnAngle) * spawnDistance;
                    const startY = visualEarthY + Math.sin(spawnAngle) * spawnDistance;
                    const angleToEarth = Math.atan2(visualEarthY - startY, visualEarthX - startX);
                    const vx = Math.cos(angleToEarth) * speed;
                    const vy = Math.sin(angleToEarth) * speed;
                    const behaviors = ['straight', 'arc', 'strafe', 'zigzag'];
                    const spritePath = type.spritePath || type.sprites[Math.floor(Math.random() * type.sprites.length)];
                    enemies.push({
                        ...type,
                        health,
                        speed,
                        spritePath,
                        x: startX,
                        y: startY,
                        vx: vx,
                        vy: vy,
                        maxHealth: health,
                        flashTimer: 0,
                        behavior: behaviors[Math.floor(Math.random() * behaviors.length)],
                        behaviorTimer: Math.random() * 10,
                        shootTimer: type.canShoot ? 0 : null,
                        rotation: angleToEarth + Math.PI / 2
                    });
                });
            }

            function showWaveModifier(modifier) {
                const banner = document.createElement("div");
                banner.className = "wave-modifier-banner";
                banner.innerHTML = `<div class="wave-modifier-title" style="color: ${modifier.color}">${modifier.name}</div><div class="wave-modifier-desc">${modifier.desc}</div>`;
                document.body.appendChild(banner);
                setTimeout(() => {
                    banner.style.opacity = "0";
                    setTimeout(() => banner.remove(), 500);
                }, 3000);
            }
            
            function showWaveChoiceScreen() {
                gameRunning = false;
                showingWaveChoice = true;
                document.getElementById('waveChoice').style.display = 'flex';
                const choiceCards = document.getElementById('choiceCards');
                if (!choiceCards) return;
                choiceCards.innerHTML = '';
                generateUpgradeChoices(3).forEach((choice) => {
                    const card = document.createElement('div');
                    card.className = 'choice-card';
                    card.innerHTML = `<div class="choice-card-name">${choice.name}</div><div class="choice-card-desc">${choice.desc}</div><div class="choice-card-effect">${choice.effect}</div>`;
                    card.onclick = () => selectWaveChoice(choice);
                    choiceCards.appendChild(card);
                });
            }
            
            function generateUpgradeChoices(count) {
                const choices = [
                    {name: "Fire Rate Boost", desc: "Fire 20% faster for this wave", effect: "+20% Fire Rate", type: "fireRate", value: 0.8},
                    {name: "Damage Boost", desc: "Deal 50% more damage", effect: "+50% Damage", type: "damage", value: 1.5},
                    {name: "Shield Heal", desc: "Restore 50 shield health", effect: "+50 Shield HP", type: "shieldHeal", value: 50},
                    {name: "Life Recovery", desc: "Gain 1 extra life", effect: "+1 Life", type: "life", value: 1},
                    {name: "Coin Multiplier", desc: "Earn 2x coins this wave", effect: "2x Coins", type: "coinMult", value: 2},
                    {name: "Missile Rain", desc: "Gain 3 extra missiles", effect: "+3 Missiles", type: "missiles", value: 3},
                    {name: "Speed Boost", desc: "Move 30% faster", effect: "+30% Speed", type: "speed", value: 1.3},
                    {name: "Piercing Shots", desc: "Bullets pierce enemies", effect: "Piercing", type: "piercing", value: true},
                    {name: "Shield Regen", desc: "Shield regenerates faster", effect: "+2 HP/sec", type: "shieldRegen", value: 2}
                ];
                return choices.sort(() => 0.5 - Math.random()).slice(0, count);
            }
            
            function selectWaveChoice(choice) {
                if (audioManager) audioManager.playSFX('upgrade');
                gameState.temporaryUpgrades.push(choice);
                if (choice.type === 'shieldHeal') {
                    gameState.shieldHealth = Math.min(gameState.shieldHealth + choice.value, gameState.maxShieldHealth);
                } else if (choice.type === 'life') {
                    lives = Math.min(lives + 1, 5);
                } else if (choice.type === 'missiles') {
                    missiles += choice.value;
                    gameState.temporaryUpgrades.push({type: 'tempMultiLock', value: 3});
                }
                updateUI();
                document.getElementById('waveChoice').style.display = 'none';
                showingWaveChoice = false;
                document.getElementById('waveTransition').style.display = 'flex';
            }

            function resumeGame() {
                document.getElementById('waveTransition').style.display = 'none';
                gameRunning = true;
                waitingForNextWave = false;
                spawnWave();
            }
            
            function updateBeamEffects(dt) {
                beamEffects = beamEffects.filter(beam => {
                    if (!beam) return false;
                    beam.lifetime -= dt;
                    const opacity = beam.lifetime / 0.3;
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(beam.startX, beam.startY);
                    ctx.lineTo(beam.endX, beam.endY);
                    ctx.stroke();
                    ctx.restore();
                    return beam.lifetime > 0;
                });
            }
            
            function updatePlasmaWaves(dt) {
                plasmaWaves = plasmaWaves.filter(wave => {
                    if (!wave) return false;
                    wave.x += wave.vx * dt * 60;
                    wave.y += wave.vy * dt * 60;
                    wave.radius += 200 * dt;
                    wave.lifetime -= dt;
                    const opacity = wave.lifetime / 1.0;
                    if (Math.random() < 0.8 && particles.length < CONFIG.MAX_PARTICLES) {
                        for (let i = 0; i < 3; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = Math.random() * wave.radius;
                            const px = wave.x + Math.cos(angle) * dist;
                            const py = wave.y + Math.sin(angle) * dist;
                            const particle = particlePool.get(
                                px, py,
                                Math.random() * 2 - 1,
                                Math.random() * 2 - 1,
                                '#00ff88',
                                0.5,
                                3
                            );
                            particles.push(particle);
                        }
                    }
                    ctx.save();
                    ctx.globalAlpha = opacity * 0.6;
                    const gradient = ctx.createRadialGradient(wave.x, wave.y, 0, wave.x, wave.y, wave.radius);
                    gradient.addColorStop(0, '#00ffff');
                    gradient.addColorStop(0.3, '#00ff88');
                    gradient.addColorStop(0.6, '#00ff00');
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(wave.x, wave.y, wave.radius * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = opacity * 0.8;
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 / 6) * i + wave.lifetime * 5;
                        ctx.beginPath();
                        ctx.moveTo(wave.x, wave.y);
                        ctx.lineTo(
                            wave.x + Math.cos(angle) * wave.radius,
                            wave.y + Math.sin(angle) * wave.radius
                        );
                        ctx.stroke();
                    }
                    ctx.restore();
                    enemies.forEach(enemy => {
                        if (!enemy || !wave.hitEnemies) return;
                        if (!wave.hitEnemies.includes(enemy)) {
                            const dist = Math.hypot(enemy.x - wave.x, enemy.y - wave.y);
                            const hitRadius = enemy.name === 'boss' ? BOSS_HIT_RADIUS : ENEMY_HIT_RADIUS;
                            if (dist < wave.radius + hitRadius) {
                                wave.hitEnemies.push(enemy);
                                const damageMultiplier = 1 + (wave.radius / 100);
                                const finalDamage = wave.damage * damageMultiplier;
                                enemy.health -= finalDamage;
                                shotsHit++;
                                if (audioManager) audioManager.playSFX('hit');
                                showDamageNumber(enemy.x, enemy.y, Math.floor(finalDamage));
                                createExplosion(enemy.x, enemy.y, 10, '#00ff88', 0.5);
                                if (enemy.health <= 0) {
                                    handleEnemyDeath(enemy);
                                }
                            }
                        }
                    });
                    return wave.lifetime > 0;
                });
            }

            function updateProjectiles(dt) {
                projectiles = projectiles.filter(p => {
                    if (!p) return false;
                    p.x += p.vx * dt * 60;
                    p.y += p.vy * dt * 60;
                    p.life -= dt;
                    if (!isInPlayArea(p.x, p.y)) return false;
                    const alpha = p.life / p.maxLife;
                    ctx.globalAlpha = alpha;
                    if (p.weaponType === 'spread') {
                        ctx.fillStyle = "#ffff00";
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 2, 0, 2 * Math.PI);
                    } else if (p.weaponType === 'rapid') {
                        ctx.fillStyle = "#ff8800";
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 2, 0, 2 * Math.PI);
                    } else if (p.weaponType === 'burst') {
                        ctx.fillStyle = "#ff00ff";
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 4, 0, 2 * Math.PI);
                    } else {
                        ctx.fillStyle = p.color || "#22d3ee";
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 3, 0, 2 * Math.PI);
                    }
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    return p.life > 0;
                });
            }
            
            function updateMissiles(dt) {
                missileProjectiles = missileProjectiles.filter(m => {
                    if (!m) return false;
                    if (m.target && enemies.find(e => e === m.target)) {
                        const dx = m.target.x - m.x;
                        const dy = m.target.y - m.y;
                        const angle = Math.atan2(dy, dx);
                        m.vx = Math.cos(angle) * 8;
                        m.vy = Math.sin(angle) * 8;
                    } else {
                        m.target = null;
                    }
                    m.x += m.vx * dt * 60;
                    m.y += m.vy * dt * 60;
                    m.life -= dt;
                    ctx.fillStyle = "#ef4444";
                    ctx.beginPath();
                    ctx.arc(m.x, m.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                    if (particles.length < CONFIG.MAX_PARTICLES) {
                        const particle = particlePool.get(m.x, m.y, 0, 0, "#f59e0b", 0.3, 2);
                        particles.push(particle);
                    }
                    return m.life > 0;
                });
            }
            
            function updateBossProjectiles(dt) {
                bossProjectiles = bossProjectiles.filter(bp => {
                    if (!bp) return false;
                    bp.x += bp.vx * dt * 60;
                    bp.y += bp.vy * dt * 60;
                    bp.rotation += dt * 5;
                    ctx.save();
                    ctx.translate(bp.x, bp.y);
                    ctx.rotate(bp.rotation);
                    const projImg = Math.random() > 0.5 ? bossProjectileImg1 : bossProjectileImg2;
                    if (projImg.complete) {
                        ctx.drawImage(projImg, -15, -15, 30, 30);
                    } else {
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(-10, -10, 20, 20);
                    }
                    ctx.restore();
                    const distToEarth = Math.hypot(bp.x - visualEarthX, bp.y - visualEarthY);
                    if (distToEarth < EARTH_COLLISION_RADIUS) {
                        if (gameState.shieldHealth > 0) {
                            gameState.shieldHealth -= 10;
                            createExplosion(bp.x, bp.y, 10, '#ff4444', 0.5);
                            if (audioManager) audioManager.playSFX('warning');
                        } else {
                            lives--;
                            updateUI();
                            createExplosion(visualEarthX, visualEarthY, 15, '#ff0000', 1);
                            if (audioManager) audioManager.playSFX('warning');
                            if (lives <= 0) endGame();
                        }
                        return false;
                    }
                    return isInPlayArea(bp.x, bp.y);
                });
            }
            
            function updateEnemies(dt) {
                const system = shopItems.systems.find(s => s.id === gameState.equipment.system);
                const slowmoMultiplier = system && system.slowmo ? system.slowmo : 1;
                enemies.forEach(enemy => {
                    if (!enemy || typeof enemy.x !== 'number' || typeof enemy.y !== 'number') return;
                    enemy.behaviorTimer += dt;
                    let speedFactor = 0.5 * slowmoMultiplier * (1 + 0.01 * (wave - 1));
                    const angleToEarth = Math.atan2(visualEarthY - enemy.y, visualEarthX - enemy.x);
                    if (enemy.name === 'boss') {
                        enemy.vx = Math.cos(angleToEarth) * enemy.speed;
                        enemy.vy = Math.sin(angleToEarth) * enemy.speed;
                        if (enemy.shootTimer !== null && enemy.shootTimer !== undefined) {
                            enemy.shootTimer += dt * 1000;
                            if (enemy.shootTimer >= enemy.shootRate) {
                                enemy.shootTimer = 0;
                                const angle = angleToEarth + (Math.random() - 0.5) * 0.5;
                                const bp = bossProjectilePool.get(
                                    enemy.x,
                                    enemy.y,
                                    Math.cos(angle) * 2,
                                    Math.sin(angle) * 2,
                                    1
                                );
                                bossProjectiles.push(bp);
                                if (audioManager) audioManager.playSFX('shoot');
                            }
                        }
                    } else {
                        let baseVx = Math.cos(angleToEarth) * enemy.speed;
                        let baseVy = Math.sin(angleToEarth) * enemy.speed;
                        switch (enemy.behavior) {
                            case 'arc':
                                const arcOffset = Math.sin(enemy.behaviorTimer * 2) * 0.3;
                                enemy.vx = baseVx + Math.cos(angleToEarth + Math.PI/2) * arcOffset;
                                enemy.vy = baseVy + Math.sin(angleToEarth + Math.PI/2) * arcOffset;
                                break;
                            case 'strafe':
                                const strafeOffset = Math.sin(enemy.behaviorTimer * 4) * 0.5;
                                enemy.vx = baseVx + Math.cos(angleToEarth + Math.PI/2) * strafeOffset;
                                enemy.vy = baseVy + Math.sin(angleToEarth + Math.PI/2) * strafeOffset;
                                break;
                            case 'zigzag':
                                const zigOffset = Math.sin(enemy.behaviorTimer * 8) * 0.6;
                                enemy.vx = baseVx + Math.cos(angleToEarth + Math.PI/2) * zigOffset;
                                enemy.vy = baseVy + Math.sin(angleToEarth + Math.PI/2) * zigOffset;
                                break;
                            default:
                                enemy.vx = baseVx;
                                enemy.vy = baseVy;
                                break;
                        }
                    }
                    enemy.x += enemy.vx * speedFactor * 60 * dt;
                    enemy.y += enemy.vy * speedFactor * 60 * dt;
                    if (enemy.x < -500 || enemy.x > canvas.width + 500 || 
                        enemy.y < -500 || enemy.y > canvas.height + 500) {
                        enemy.health = 0;
                        return;
                    }
                    if (enemy.flashTimer > 0) enemy.flashTimer -= dt;
                    const enemyImage = enemyImages[enemy.spritePath];
                    const size = enemy.name === 'boss' ? 160 : 50;
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y);
                    const rotation = Math.atan2(visualEarthY - enemy.y, visualEarthX - enemy.x);
                    // Different rotation offset for boss vs regular enemies based on sprite orientation
                    const rotationOffset = enemy.name === 'boss' ? Math.PI * 1.5 : Math.PI / 2;
                    ctx.rotate(rotation + rotationOffset);
                    ctx.globalCompositeOperation = 'lighter';
                    if (enemyImage && enemyImage.complete && enemyImage.naturalHeight !== 0) {
                        ctx.drawImage(enemyImage, -size/2, -size/2, size, size);
                    } else {
                        ctx.fillStyle = enemy.color || '#ef4444';
                        ctx.beginPath();
                        ctx.arc(0, 0, size/2, 0, 2*Math.PI);
                        ctx.fill();
                    }
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.restore();
                    if (enemy.health < enemy.maxHealth) {
                        const barWidth = size * 0.8;
                        const barHeight = 5;
                        const healthPercent = Math.max(0, Math.min(1, enemy.health / enemy.maxHealth));
                        ctx.fillStyle = 'rgba(0,0,0,0.5)';
                        ctx.fillRect(enemy.x - barWidth/2, enemy.y - size/2 - 12, barWidth, barHeight);
                        ctx.fillStyle = healthPercent > 0.3 ? '#10b981' : '#ef4444';
                        ctx.fillRect(enemy.x - barWidth/2, enemy.y - size/2 - 12, barWidth * healthPercent, barHeight);
                    }
                    const dist = Math.hypot(enemy.x - visualEarthX, enemy.y - visualEarthY);
                    if (dist < EARTH_COLLISION_RADIUS && gameState.shieldHealth > 0) {
                        const shield = shopItems.shields.find(s => s.id === gameState.equipment.shield);
                        if (shield && shield.reflect && Math.random() < shield.reflect) {
                            createExplosion(enemy.x, enemy.y, 15, enemy.color, 0.8, enemy.name === 'boss');
                            if (audioManager) audioManager.playSFX(enemy.name === 'boss' ? 'bossExplode' : 'explosion');
                            deathStats.enemiesKilled++;
                            coins += enemy.coins;
                            score += 2 * enemy.coins;
                            addCombo();
                            enemy.health = 0;
                        } else {
                            gameState.shieldHealth -= enemy.health;
                            if (shield && shield.absorb) {
                                coins += Math.floor(2 * enemy.health);
                            }
                            createExplosion(enemy.x, enemy.y, 12, enemy.color, 0.6, enemy.name === 'boss');
                            if (audioManager) audioManager.playSFX('warning');
                            screenShake += 5;
                            vibrate(30);
                            enemy.health = 0;
                        }
                    }
                    if (dist < EARTH_IMPACT_RADIUS) {
                        lives--;
                        updateUI();
                        createExplosion(visualEarthX, visualEarthY, 20, '#ef4444', 1.2);
                        if (audioManager) audioManager.playSFX('warning');
                        screenShake += 15;
                        vibrate(100);
                        comboCount = 0;
                        updateComboDisplay();
                        if (lives <= 0) endGame();
                        enemy.health = 0;
                    }
                });
                enemies = enemies.filter(e => e && e.health > 0);
            }

            function updateParticles(dt) {
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    if (!p) continue;
                    
                    // Update particle physics
                    p.x += p.vx * dt * 60;
                    p.y += p.vy * dt * 60;
                    p.vy += 0.5;
                    p.lifetime -= dt;
                    
                    // Check if dead
                    if (p.lifetime <= 0) {
                        particlePool.release(p);
                        particles.splice(i, 1);
                    } else {
                        // Draw particle
                        const alpha = p.lifetime / p.maxLifetime;
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                }
            }
            
            function updateExplosions(dt) {
                explosions = explosions.filter(e => {
                    if (!e) return false;
                    let alpha = 1 - e.size / e.maxSize;
                    e.size += 150 * dt;
                    ctx.globalAlpha = alpha;
                    ctx.strokeStyle = e.color || "#f59e0b";
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.size, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.strokeStyle = e.color || "#ef4444";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, 0.7 * e.size, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    return e.size < e.maxSize;
                });
            }
            
            function autoFire(dt) {
                const weapon = shopItems.weapons.find(w => w.id === gameState.equipment.weapon);
                if (!weapon) return;
                let fireRate = weapon.fireRate;
                const fireRateUpgrade = gameState.temporaryUpgrades.find(u => u.type === 'fireRate');
                if (fireRateUpgrade) fireRate *= fireRateUpgrade.value;
                if (weapon.burst && burstCounter > 0) {
                    autoFireTimer += dt * 1000;
                    if (autoFireTimer >= 100) {
                        autoFireTimer = 0;
                        burstCounter--;
                        fireWeapon(weapon);
                    }
                    return;
                }
                autoFireTimer += dt * 1000;
                if (autoFireTimer >= fireRate) {
                    autoFireTimer = 0;
                    if (weapon.burst) {
                        burstCounter = weapon.burst - 1;
                    }
                    fireWeapon(weapon);
                }
            }

            function fireWeapon(weapon) {
                shotsFired++;
                if (audioManager) audioManager.playSFX('shoot');
                let damage = weapon.damage;
                const damageUpgrade = gameState.temporaryUpgrades.find(u => u.type === 'damage');
                if (damageUpgrade) damage *= damageUpgrade.value;
                const hasPiercing = weapon.piercing || gameState.temporaryUpgrades.some(u => u.type === 'piercing');
                if (weapon.beam) {
                    const beamLength = 1000;
                    const endX = shipX + Math.cos(shipAngle) * beamLength;
                    const endY = shipY + Math.sin(shipAngle) * beamLength;
                    beamEffects.push({
                        startX: shipX,
                        startY: shipY,
                        endX: endX,
                        endY: endY,
                        lifetime: 0.3
                    });
                    enemies.forEach(enemy => {
                        if (!enemy) return;
                        const dist = pointToLineDistance(enemy.x, enemy.y, shipX, shipY, endX, endY);
                        const hitRadius = enemy.name === 'boss' ? BOSS_HIT_RADIUS : ENEMY_HIT_RADIUS;
                        if (dist < hitRadius) {
                            enemy.health -= damage;
                            shotsHit++;
                            if (audioManager) audioManager.playSFX(enemy.name === 'boss' ? 'bossHit' : 'hit');
                            showDamageNumber(enemy.x, enemy.y, damage);
                            if (enemy.health <= 0) {
                                handleEnemyDeath(enemy);
                            }
                        }
                    });
                    vibrate(30);
                } else if (weapon.wave) {
                    plasmaWaves.push({
                        x: shipX,
                        y: shipY,
                        vx: Math.cos(shipAngle) * 5,
                        vy: Math.sin(shipAngle) * 5,
                        radius: 30,
                        lifetime: 1.0,
                        damage: damage,
                        hitEnemies: []
                    });
                    vibrate(30);
                } else if (weapon.pattern === 'spread') {
                    for (let i = -2; i <= 2; i++) {
                        const spreadAngle = shipAngle + i * 0.15;
                        const proj = projectilePool.get(
                            shipX, shipY,
                            Math.cos(spreadAngle) * 12,
                            Math.sin(spreadAngle) * 12,
                            damage,
                            hasPiercing,
                            'spread'
                        );
                        projectiles.push(proj);
                    }
                } else {
                    const speed = weapon.rapid ? 15 : 10;
                    const proj = projectilePool.get(
                        shipX, shipY,
                        Math.cos(shipAngle) * speed,
                        Math.sin(shipAngle) * speed,
                        damage,
                        hasPiercing,
                        weapon.id
                    );
                    projectiles.push(proj);
                }
                vibrate(10);
            }
            
            function pointToLineDistance(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) param = dot / lenSq;
                let xx, yy;
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            function handleEnemyDeath(enemy) {
                if (!enemy) return;
                if (audioManager) {
                    audioManager.playSFX(enemy.name === 'boss' ? 'bossExplode' : 'explosion');
                    if (enemy.name === 'boss') {
                        audioManager.duckMusic(0.5, 0.3);
                    }
                }
                deathStats.enemiesKilled++;
                const coinMultUpgrade = gameState.temporaryUpgrades.find(u => u.type === 'coinMult');
                let coinEarned = enemy.coins * (coinMultUpgrade ? coinMultUpgrade.value : 1);
                coins += coinEarned;
                score += coinEarned * 2;
                addCombo();
                createExplosion(enemy.x, enemy.y, enemy.name === 'boss' ? 40 : 20, enemy.color || '#fff', enemy.name === 'boss' ? 2 : 1.2, enemy.name === 'boss');
                if (enemy.name === 'boss') {
                    explosions.push({ x: enemy.x, y: enemy.y, size: 0, maxSize: 120, color: enemy.color || '#fff' });
                }
            }

            function launchMissile() {
                if (missiles <= 0 || !gameRunning) return;
                if (audioManager) {
                    audioManager.playSFX("missile");
                    audioManager.duckMusic(0.4, 0.5);
                }
                missiles--;
                updateUI();
                const system = shopItems.systems.find(s => s.id === gameState.equipment.system);
                const tempMulti = gameState.temporaryUpgrades.find(u => u.type === 'tempMultiLock');
                const multiTarget = (tempMulti && tempMulti.value) || (system && system.multiTarget) || 1;
                const targetEnemies = enemies.sort((a, b) => {
                    if (!a || !b) return 0;
                    return Math.hypot(a.x - shipX, a.y - shipY) - Math.hypot(b.x - shipX, b.y - shipY);
                }).slice(0, multiTarget);
                targetEnemies.forEach(target => {
                    if (!target) return;
                    const missile = missilePool.get(
                        shipX, shipY,
                        Math.cos(shipAngle) * 5,
                        Math.sin(shipAngle) * 5,
                        target
                    );
                    missileProjectiles.push(missile);
                });
                vibrate(50);
            }
            
            function checkCollisions() {
                enemyGrid.clear();
                bossProjectileGrid.clear();
                enemies.forEach(e => e && enemyGrid.insert(e));
                bossProjectiles.forEach(bp => bp && bossProjectileGrid.insert(bp));
                
                const enemiesToRemove = [];
                
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    if (!p) continue;
                    const nearbyEnemies = enemyGrid.getNearby(p.x, p.y, 100);
                    for (let j = 0; j < nearbyEnemies.length; j++) {
                        const enemy = nearbyEnemies[j];
                        if (!enemy || enemy.health <= 0) continue;
                        const hitRadius = enemy.name === 'boss' ? BOSS_HIT_RADIUS : ENEMY_HIT_RADIUS;
                        const dist = Math.hypot(p.x - enemy.x, p.y - enemy.y);
                        if (dist < hitRadius) {
                            shotsHit++;
                            if (audioManager) audioManager.playSFX(enemy.name === 'boss' ? 'bossHit' : 'hit');
                            if (enemy.name === 'boss') {
                                triggerHitPause(0.1, 0.2);
                            } else {
                                triggerHitPause(0.03, 0.5);
                            }
                            const finalDamage = Math.ceil(p.damage);
                            enemy.health -= finalDamage;
                            enemy.flashTimer = 0.1;
                            showDamageNumber(enemy.x, enemy.y, finalDamage);
                            if (enemy.health <= 0) {
                                handleEnemyDeath(enemy);
                                enemiesToRemove.push(enemy);
                            }
                            if (!p.piercing) {
                                projectiles.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    if (!p) continue;
                    const nearbyBossProjectiles = bossProjectileGrid.getNearby(p.x, p.y, 50);
                    for (let j = 0; j < nearbyBossProjectiles.length; j++) {
                        const bp = nearbyBossProjectiles[j];
                        if (!bp) continue;
                        if (Math.hypot(p.x - bp.x, p.y - bp.y) < 20) {
                            createExplosion(bp.x, bp.y, 8, '#ff8800', 0.5);
                            score += 5;
                            const bpIndex = bossProjectiles.indexOf(bp);
                            if (bpIndex > -1) {
                                bossProjectiles.splice(bpIndex, 1);
                            }
                            if (!p.piercing) {
                                projectiles.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
                for (let i = missileProjectiles.length - 1; i >= 0; i--) {
                    const m = missileProjectiles[i];
                    if (!m) continue;
                    const nearbyEnemies = enemyGrid.getNearby(m.x, m.y, 100);
                    for (let j = 0; j < nearbyEnemies.length; j++) {
                        const enemy = nearbyEnemies[j];
                        if (!enemy || enemy.health <= 0) continue;
                        const hitRadius = enemy.name === 'boss' ? BOSS_HIT_RADIUS : ENEMY_HIT_RADIUS;
                        if (Math.hypot(m.x - enemy.x, m.y - enemy.y) < hitRadius) {
                            enemy.health -= m.damage;
                            createExplosion(m.x, m.y, 15, '#ef4444', 0.8, enemy.name === 'boss');
                            if (enemy.health <= 0) {
                                handleEnemyDeath(enemy);
                                enemiesToRemove.push(enemy);
                            }
                            missileProjectiles.splice(i, 1);
                            break;
                        }
                    }
                }
                
                // Remove all dead enemies at once
                if (enemiesToRemove.length > 0) {
                    enemies = enemies.filter(e => !enemiesToRemove.includes(e));
                }
                
                deathStats.accuracy = shotsFired > 0 ? `${(shotsHit / shotsFired * 100).toFixed(1)}%` : '0%';
            }

            function endGame() {
                if (audioManager) {
                    audioManager.stopMusic(500);
                    setTimeout(() => audioManager.playMusic('gameover', 500), 600);
                }
                gameRunning = false;
                document.getElementById('hud').style.display = 'none';
                document.getElementById('missileButton').style.display = 'none';
                showDeathScreen();
            }
            
            function showVictoryScreen() {
                if (audioManager) {
                    audioManager.stopMusic(500);
                    setTimeout(() => audioManager.playMusic('victory', 500), 600);
                }
                gameRunning = false;
                document.getElementById('hud').style.display = 'none';
                document.getElementById('missileButton').style.display = 'none';
                document.getElementById('victoryScreen').style.display = 'flex';
                saveGameState();
            }
            
            function closeVictoryScreen() {
                if (audioManager) audioManager.playMusic('menu');
                document.getElementById('victoryScreen').style.display = 'none';
                document.getElementById('menu').style.display = 'block';
                document.getElementById('titleImage').style.display = 'block';
            }
            
            function showDeathScreen() {
                const deathScreen = document.getElementById("deathScreen");
                const statsEl = document.getElementById("deathStats");
                const recommendEl = document.getElementById("deathRecommendation");
                if (!deathScreen || !statsEl || !recommendEl) return;
                deathStats.coinsEarned = coins - deathStats.coinsEarned;
                const statsHTML = `
                    <div class="death-stat-row"><span class="death-stat-label">Waves Survived</span><span class="death-stat-value">${deathStats.waveReached - 1}</span></div>
                    <div class="death-stat-row"><span class="death-stat-label">Enemies Killed</span><span class="death-stat-value">${deathStats.enemiesKilled}</span></div>
                    <div class="death-stat-row"><span class="death-stat-label">Final Score</span><span class="death-stat-value">${score}</span></div>
                    <div class="death-stat-row"><span class="death-stat-label">High Score</span><span class="death-stat-value">${highScore}</span></div>
                    <div class="death-stat-row"><span class="death-stat-label">Coins Earned</span><span class="death-stat-value">${deathStats.coinsEarned}</span></div>
                    <div class="death-stat-row"><span class="death-stat-label">Accuracy</span><span class="death-stat-value">${deathStats.accuracy}</span></div>
                `;
                statsEl.innerHTML = statsHTML;
                let recommendation = "";
                if (deathStats.waveReached < 5) {
                    recommendation = "Consider upgrading your weapon or shield in the shop.";
                } else if (deathStats.waveReached < 10) {
                    recommendation = "You're making progress! Try the Spread Shot or Rail Gun.";
                } else {
                    recommendation = "Impressive! You're a skilled defender.";
                }
                recommendEl.textContent = recommendation;
                deathScreen.style.display = "flex";
                saveGameState();
            }
            
            function closeDeathScreen() {
                if (audioManager) audioManager.playMusic('menu');
                document.getElementById('deathScreen').style.display = 'none';
                document.getElementById('menu').style.display = 'block';
                document.getElementById('titleImage').style.display = 'block';
            }
            
            function updateUI() {
                const waveEl = document.getElementById('waveDisplay');
                const scoreEl = document.getElementById('scoreDisplay');
                const livesEl = document.getElementById('livesDisplay');
                const coinsEl = document.getElementById('coinsDisplay');
                const missilesEl = document.getElementById('missilesDisplay');
                const shopBalanceEl = document.getElementById('shopBalance');
                if (waveEl) waveEl.textContent = wave;
                if (scoreEl) scoreEl.textContent = score;
                if (livesEl) livesEl.textContent = lives;
                if (coinsEl) coinsEl.textContent = coins;
                if (missilesEl) missilesEl.textContent = missiles;
                if (shopBalanceEl) shopBalanceEl.textContent = `💰 ${coins}`;
            }
            
            function showShop() {
                if (document.getElementById('menu').style.display !== 'none' || document.getElementById('deathScreen').style.display !== 'none') {
                    shopReturnState = 'menu';
                }
                document.getElementById('menu').style.display = 'none';
                document.getElementById('deathScreen').style.display = 'none';
                document.getElementById('shop').style.display = 'flex';
                renderShop('weapons');
            }
            
            function closeShop() {
                document.getElementById('shop').style.display = 'none';
                if (shopReturnState === 'in_game') {
                    document.getElementById('waveTransition').style.display = 'flex';
                } else {
                    document.getElementById('menu').style.display = 'block';
                }
            }
            
            function showInGameShop() {
                shopReturnState = 'in_game';
                document.getElementById('waveTransition').style.display = 'none';
                showShop();
            }
            
            function showTutorial() {
                document.getElementById('menu').style.display = 'none';
                document.getElementById('tutorial').style.display = 'flex';
            }
            
            function closeTutorial() {
                document.getElementById('tutorial').style.display = 'none';
                document.getElementById('menu').style.display = 'block';
            }

            function switchTab(tabName) {
                document.querySelectorAll(".tab").forEach(tab => tab.classList.remove("active"));
                event.target.classList.add("active");
                renderShop(tabName);
            }
            
            function renderShop(category) {
                const shopItemsEl = document.getElementById("shopItems");
                if (!shopItemsEl) return;
                shopItemsEl.innerHTML = "";
                const equipmentKey = category === "weapons" ? "weapon" : category === "shields" ? "shield" : "system";
                const items = shopItems[category];
                if (!items) return;
                items.forEach(item => {
                    const owned = gameState.owned[category].includes(item.id);
                    const equipped = gameState.equipment[equipmentKey] === item.id;
                    const canAfford = coins >= item.cost;
                    const card = document.createElement("div");
                    card.className = `item-card ${equipped ? "equipped" : ""}`;
                    card.innerHTML = `
                        <img src="${item.sprite}" class="item-sprite" alt="${item.name}" onerror="this.style.display='none'">
                        <div class="item-name">${item.name}</div>
                        <div class="item-desc">${item.desc}</div>
                        <div class="item-price">${item.cost > 0 ? `💰 ${item.cost}` : "Free"}</div>
                        ${equipped ? '<div class="item-equipped-badge">Equipped</div>' : ""}
                    `;
                    if (!owned && item.cost > 0) {
                        const btn = document.createElement("button");
                        btn.className = "button";
                        btn.textContent = canAfford ? "Buy" : "Not enough coins";
                        btn.disabled = !canAfford;
                        btn.onclick = () => buyItem(category, item.id);
                        card.appendChild(btn);
                    } else if (!equipped) {
                        const btn = document.createElement("button");
                        btn.className = "button";
                        btn.textContent = "Equip";
                        btn.onclick = () => equipItem(category, item.id);
                        card.appendChild(btn);
                    }
                    shopItemsEl.appendChild(card);
                });
            }
            
            function buyItem(category, itemId) {
                const item = shopItems[category].find(i => i.id === itemId);
                if (!item || coins < item.cost) return;
                coins -= item.cost;
                if (audioManager) audioManager.playSFX("powerup");
                gameState.owned[category].push(itemId);
                updateUI();
                saveGameState();
                renderShop(category);
                vibrate(30);
            }
            
            function equipItem(category, itemId) {
                const equipmentKey = category === "weapons" ? "weapon" : category === "shields" ? "shield" : "system";
                gameState.equipment[equipmentKey] = itemId;
                if (category === "shields") {
                    const shield = shopItems.shields.find(s => s.id === itemId);
                    if (shield) {
                        gameState.maxShieldHealth = shield.health || 0;
                        gameState.shieldHealth = shield.health || 0;
                    }
                }
                saveGameState();
                renderShop(category);
                vibrate(20);
            }

            init();
            
            return {
                startGame,
                showShop,
                closeShop,
                switchTab,
                launchMissile,
                closeDeathScreen,
                closeVictoryScreen,
                resumeGame,
                showInGameShop,
                showTutorial,
                closeTutorial,
                setDifficulty
            };
        }

        window.addEventListener('load', () => {
            Game = initializeGame();
            // Position UI immediately to prevent jump
            setTimeout(() => {
                if (Game && typeof Game.positionUIElements === 'function') {
                    Game.positionUIElements();
                }
            }, 0);
        });
    </script>

</body>
</html>
